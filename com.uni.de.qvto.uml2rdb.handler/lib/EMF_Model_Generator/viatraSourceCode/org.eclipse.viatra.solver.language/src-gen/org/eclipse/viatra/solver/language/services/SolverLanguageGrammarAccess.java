/*
 * generated by Xtext 2.12.0
 */
package org.eclipse.viatra.solver.language.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.UnorderedGroup;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractEnumRuleElementFinder;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class SolverLanguageGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ProblemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Problem");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Keyword cProblemKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cNameAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cNameQualifiedNameParserRuleCall_0_1_0 = (RuleCall)cNameAssignment_0_1.eContents().get(0);
		private final RuleCall cFULL_STOPTerminalRuleCall_0_2 = (RuleCall)cGroup_0.eContents().get(2);
		private final Assignment cImportsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cImportsImportParserRuleCall_1_0 = (RuleCall)cImportsAssignment_1.eContents().get(0);
		private final Assignment cStatementsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStatementsStatementParserRuleCall_2_0 = (RuleCall)cStatementsAssignment_2.eContents().get(0);
		
		//Problem:
		//	("problem" name=QualifiedName FULL_STOP)?
		//	imports+=Import*
		//	statements+=Statement*;
		@Override public ParserRule getRule() { return rule; }
		
		//("problem" name=QualifiedName FULL_STOP)? imports+=Import* statements+=Statement*
		public Group getGroup() { return cGroup; }
		
		//("problem" name=QualifiedName FULL_STOP)?
		public Group getGroup_0() { return cGroup_0; }
		
		//"problem"
		public Keyword getProblemKeyword_0_0() { return cProblemKeyword_0_0; }
		
		//name=QualifiedName
		public Assignment getNameAssignment_0_1() { return cNameAssignment_0_1; }
		
		//QualifiedName
		public RuleCall getNameQualifiedNameParserRuleCall_0_1_0() { return cNameQualifiedNameParserRuleCall_0_1_0; }
		
		//FULL_STOP
		public RuleCall getFULL_STOPTerminalRuleCall_0_2() { return cFULL_STOPTerminalRuleCall_0_2; }
		
		//imports+=Import*
		public Assignment getImportsAssignment_1() { return cImportsAssignment_1; }
		
		//Import
		public RuleCall getImportsImportParserRuleCall_1_0() { return cImportsImportParserRuleCall_1_0; }
		
		//statements+=Statement*
		public Assignment getStatementsAssignment_2() { return cStatementsAssignment_2; }
		
		//Statement
		public RuleCall getStatementsStatementParserRuleCall_2_0() { return cStatementsStatementParserRuleCall_2_0; }
	}
	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAssertionOrDefinitionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPredicateDefinitionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cUnnamedErrorPredicateDefintionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cDefaultAssertionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cFunctionDefinitionParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cAttributeParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cExternDeclarationParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cScopeDeclarationParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cObjectiveDeclarationParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cClassDeclarationParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cEnumDeclarationParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		
		//Statement:
		//	AssertionOrDefinition | PredicateDefinition | UnnamedErrorPredicateDefintion | DefaultAssertion | FunctionDefinition
		//	| Attribute | ExternDeclaration | ScopeDeclaration | ObjectiveDeclaration | ClassDeclaration | EnumDeclaration;
		@Override public ParserRule getRule() { return rule; }
		
		//AssertionOrDefinition | PredicateDefinition | UnnamedErrorPredicateDefintion | DefaultAssertion | FunctionDefinition |
		//Attribute | ExternDeclaration | ScopeDeclaration | ObjectiveDeclaration | ClassDeclaration | EnumDeclaration
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//AssertionOrDefinition
		public RuleCall getAssertionOrDefinitionParserRuleCall_0() { return cAssertionOrDefinitionParserRuleCall_0; }
		
		//PredicateDefinition
		public RuleCall getPredicateDefinitionParserRuleCall_1() { return cPredicateDefinitionParserRuleCall_1; }
		
		//UnnamedErrorPredicateDefintion
		public RuleCall getUnnamedErrorPredicateDefintionParserRuleCall_2() { return cUnnamedErrorPredicateDefintionParserRuleCall_2; }
		
		//DefaultAssertion
		public RuleCall getDefaultAssertionParserRuleCall_3() { return cDefaultAssertionParserRuleCall_3; }
		
		//FunctionDefinition
		public RuleCall getFunctionDefinitionParserRuleCall_4() { return cFunctionDefinitionParserRuleCall_4; }
		
		//Attribute
		public RuleCall getAttributeParserRuleCall_5() { return cAttributeParserRuleCall_5; }
		
		//ExternDeclaration
		public RuleCall getExternDeclarationParserRuleCall_6() { return cExternDeclarationParserRuleCall_6; }
		
		//ScopeDeclaration
		public RuleCall getScopeDeclarationParserRuleCall_7() { return cScopeDeclarationParserRuleCall_7; }
		
		//ObjectiveDeclaration
		public RuleCall getObjectiveDeclarationParserRuleCall_8() { return cObjectiveDeclarationParserRuleCall_8; }
		
		//ClassDeclaration
		public RuleCall getClassDeclarationParserRuleCall_9() { return cClassDeclarationParserRuleCall_9; }
		
		//EnumDeclaration
		public RuleCall getEnumDeclarationParserRuleCall_10() { return cEnumDeclarationParserRuleCall_10; }
	}
	public class ImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Import");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUriImportParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNamespaceImportParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Import:
		//	UriImport | NamespaceImport;
		@Override public ParserRule getRule() { return rule; }
		
		//UriImport | NamespaceImport
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//UriImport
		public RuleCall getUriImportParserRuleCall_0() { return cUriImportParserRuleCall_0; }
		
		//NamespaceImport
		public RuleCall getNamespaceImportParserRuleCall_1() { return cNamespaceImportParserRuleCall_1; }
	}
	public class UriImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.UriImport");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cUriAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cUriSTRINGTerminalRuleCall_1_0 = (RuleCall)cUriAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cAsKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cAliasAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cAliasQualifiedNameParserRuleCall_2_1_0 = (RuleCall)cAliasAssignment_2_1.eContents().get(0);
		private final RuleCall cFULL_STOPTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		//UriImport:
		//	"import" uri=STRING ("as" alias=QualifiedName) FULL_STOP;
		@Override public ParserRule getRule() { return rule; }
		
		//"import" uri=STRING ("as" alias=QualifiedName) FULL_STOP
		public Group getGroup() { return cGroup; }
		
		//"import"
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }
		
		//uri=STRING
		public Assignment getUriAssignment_1() { return cUriAssignment_1; }
		
		//STRING
		public RuleCall getUriSTRINGTerminalRuleCall_1_0() { return cUriSTRINGTerminalRuleCall_1_0; }
		
		//"as" alias=QualifiedName
		public Group getGroup_2() { return cGroup_2; }
		
		//"as"
		public Keyword getAsKeyword_2_0() { return cAsKeyword_2_0; }
		
		//alias=QualifiedName
		public Assignment getAliasAssignment_2_1() { return cAliasAssignment_2_1; }
		
		//QualifiedName
		public RuleCall getAliasQualifiedNameParserRuleCall_2_1_0() { return cAliasQualifiedNameParserRuleCall_2_1_0; }
		
		//FULL_STOP
		public RuleCall getFULL_STOPTerminalRuleCall_3() { return cFULL_STOPTerminalRuleCall_3; }
	}
	public class NamespaceImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.NamespaceImport");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cImportedNamespaceAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cImportedNamespaceQualifiedNameParserRuleCall_1_0 = (RuleCall)cImportedNamespaceAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cAsKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cAliasAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cAliasQualifiedNameParserRuleCall_2_1_0 = (RuleCall)cAliasAssignment_2_1.eContents().get(0);
		private final RuleCall cFULL_STOPTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		//NamespaceImport:
		//	"import" importedNamespace=QualifiedName ("as" alias=QualifiedName) FULL_STOP;
		@Override public ParserRule getRule() { return rule; }
		
		//"import" importedNamespace=QualifiedName ("as" alias=QualifiedName) FULL_STOP
		public Group getGroup() { return cGroup; }
		
		//"import"
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }
		
		//importedNamespace=QualifiedName
		public Assignment getImportedNamespaceAssignment_1() { return cImportedNamespaceAssignment_1; }
		
		//QualifiedName
		public RuleCall getImportedNamespaceQualifiedNameParserRuleCall_1_0() { return cImportedNamespaceQualifiedNameParserRuleCall_1_0; }
		
		//"as" alias=QualifiedName
		public Group getGroup_2() { return cGroup_2; }
		
		//"as"
		public Keyword getAsKeyword_2_0() { return cAsKeyword_2_0; }
		
		//alias=QualifiedName
		public Assignment getAliasAssignment_2_1() { return cAliasAssignment_2_1; }
		
		//QualifiedName
		public RuleCall getAliasQualifiedNameParserRuleCall_2_1_0() { return cAliasQualifiedNameParserRuleCall_2_1_0; }
		
		//FULL_STOP
		public RuleCall getFULL_STOPTerminalRuleCall_3() { return cFULL_STOPTerminalRuleCall_3; }
	}
	public class AssertionOrDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.AssertionOrDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Action cAssertionExpressionAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Group cGroup_1_0_1 = (Group)cGroup_1_0.eContents().get(1);
		private final Keyword cColonKeyword_1_0_1_0 = (Keyword)cGroup_1_0_1.eContents().get(0);
		private final Assignment cRangeAssignment_1_0_1_1 = (Assignment)cGroup_1_0_1.eContents().get(1);
		private final RuleCall cRangeExpressionParserRuleCall_1_0_1_1_0 = (RuleCall)cRangeAssignment_1_0_1_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Action cPredicateDefinitionHeadAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Keyword cColonHyphenMinusKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		private final Assignment cBodyAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cBodyExpressionParserRuleCall_1_1_2_0 = (RuleCall)cBodyAssignment_1_1_2.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cAlternatives_1.eContents().get(2);
		private final Action cFunctionDefinitionHeadAction_1_2_0 = (Action)cGroup_1_2.eContents().get(0);
		private final Keyword cColonEqualsSignKeyword_1_2_1 = (Keyword)cGroup_1_2.eContents().get(1);
		private final Assignment cBodyAssignment_1_2_2 = (Assignment)cGroup_1_2.eContents().get(2);
		private final RuleCall cBodyExpressionParserRuleCall_1_2_2_0 = (RuleCall)cBodyAssignment_1_2_2.eContents().get(0);
		private final RuleCall cFULL_STOPTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//AssertionOrDefinition Statement:
		//	Expression ({Assertion.expression=current} (":" range=Expression)? | {PredicateDefinition.head=current} ":-"
		//	body=Expression | {FunctionDefinition.head=current} ":=" body=Expression) FULL_STOP;
		@Override public ParserRule getRule() { return rule; }
		
		//Expression ({Assertion.expression=current} (":" range=Expression)? | {PredicateDefinition.head=current} ":-"
		//body=Expression | {FunctionDefinition.head=current} ":=" body=Expression) FULL_STOP
		public Group getGroup() { return cGroup; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_0() { return cExpressionParserRuleCall_0; }
		
		//{Assertion.expression=current} (":" range=Expression)? | {PredicateDefinition.head=current} ":-" body=Expression |
		//{FunctionDefinition.head=current} ":=" body=Expression
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//{Assertion.expression=current} (":" range=Expression)?
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{Assertion.expression=current}
		public Action getAssertionExpressionAction_1_0_0() { return cAssertionExpressionAction_1_0_0; }
		
		//(":" range=Expression)?
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }
		
		//":"
		public Keyword getColonKeyword_1_0_1_0() { return cColonKeyword_1_0_1_0; }
		
		//range=Expression
		public Assignment getRangeAssignment_1_0_1_1() { return cRangeAssignment_1_0_1_1; }
		
		//Expression
		public RuleCall getRangeExpressionParserRuleCall_1_0_1_1_0() { return cRangeExpressionParserRuleCall_1_0_1_1_0; }
		
		//{PredicateDefinition.head=current} ":-" body=Expression
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//{PredicateDefinition.head=current}
		public Action getPredicateDefinitionHeadAction_1_1_0() { return cPredicateDefinitionHeadAction_1_1_0; }
		
		//":-"
		public Keyword getColonHyphenMinusKeyword_1_1_1() { return cColonHyphenMinusKeyword_1_1_1; }
		
		//body=Expression
		public Assignment getBodyAssignment_1_1_2() { return cBodyAssignment_1_1_2; }
		
		//Expression
		public RuleCall getBodyExpressionParserRuleCall_1_1_2_0() { return cBodyExpressionParserRuleCall_1_1_2_0; }
		
		//{FunctionDefinition.head=current} ":=" body=Expression
		public Group getGroup_1_2() { return cGroup_1_2; }
		
		//{FunctionDefinition.head=current}
		public Action getFunctionDefinitionHeadAction_1_2_0() { return cFunctionDefinitionHeadAction_1_2_0; }
		
		//":="
		public Keyword getColonEqualsSignKeyword_1_2_1() { return cColonEqualsSignKeyword_1_2_1; }
		
		//body=Expression
		public Assignment getBodyAssignment_1_2_2() { return cBodyAssignment_1_2_2; }
		
		//Expression
		public RuleCall getBodyExpressionParserRuleCall_1_2_2_0() { return cBodyExpressionParserRuleCall_1_2_2_0; }
		
		//FULL_STOP
		public RuleCall getFULL_STOPTerminalRuleCall_2() { return cFULL_STOPTerminalRuleCall_2; }
	}
	public class PredicateDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.PredicateDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cAlternatives_0.eContents().get(0);
		private final Assignment cFunctionalAssignment_0_0_0 = (Assignment)cGroup_0_0.eContents().get(0);
		private final Keyword cFunctionalFunctionalKeyword_0_0_0_0 = (Keyword)cFunctionalAssignment_0_0_0.eContents().get(0);
		private final Assignment cErrorAssignment_0_0_1 = (Assignment)cGroup_0_0.eContents().get(1);
		private final Keyword cErrorErrorKeyword_0_0_1_0 = (Keyword)cErrorAssignment_0_0_1.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cAlternatives_0.eContents().get(1);
		private final Assignment cErrorAssignment_0_1_0 = (Assignment)cGroup_0_1.eContents().get(0);
		private final Keyword cErrorErrorKeyword_0_1_0_0 = (Keyword)cErrorAssignment_0_1_0.eContents().get(0);
		private final Assignment cFunctionalAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final Keyword cFunctionalFunctionalKeyword_0_1_1_0 = (Keyword)cFunctionalAssignment_0_1_1.eContents().get(0);
		private final Assignment cHeadAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cHeadCallParserRuleCall_1_0 = (RuleCall)cHeadAssignment_1.eContents().get(0);
		private final Keyword cColonHyphenMinusKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cBodyAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBodyExpressionParserRuleCall_3_0 = (RuleCall)cBodyAssignment_3.eContents().get(0);
		private final RuleCall cFULL_STOPTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//PredicateDefinition:
		//	(functional?="functional" error?="error"? | error?="error" functional?="functional"?) head=Call ":-" body=Expression
		//	FULL_STOP;
		@Override public ParserRule getRule() { return rule; }
		
		//(functional?="functional" error?="error"? | error?="error" functional?="functional"?) head=Call ":-" body=Expression
		//FULL_STOP
		public Group getGroup() { return cGroup; }
		
		//functional?="functional" error?="error"? | error?="error" functional?="functional"?
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//functional?="functional" error?="error"?
		public Group getGroup_0_0() { return cGroup_0_0; }
		
		//functional?="functional"
		public Assignment getFunctionalAssignment_0_0_0() { return cFunctionalAssignment_0_0_0; }
		
		//"functional"
		public Keyword getFunctionalFunctionalKeyword_0_0_0_0() { return cFunctionalFunctionalKeyword_0_0_0_0; }
		
		//error?="error"?
		public Assignment getErrorAssignment_0_0_1() { return cErrorAssignment_0_0_1; }
		
		//"error"
		public Keyword getErrorErrorKeyword_0_0_1_0() { return cErrorErrorKeyword_0_0_1_0; }
		
		//error?="error" functional?="functional"?
		public Group getGroup_0_1() { return cGroup_0_1; }
		
		//error?="error"
		public Assignment getErrorAssignment_0_1_0() { return cErrorAssignment_0_1_0; }
		
		//"error"
		public Keyword getErrorErrorKeyword_0_1_0_0() { return cErrorErrorKeyword_0_1_0_0; }
		
		//functional?="functional"?
		public Assignment getFunctionalAssignment_0_1_1() { return cFunctionalAssignment_0_1_1; }
		
		//"functional"
		public Keyword getFunctionalFunctionalKeyword_0_1_1_0() { return cFunctionalFunctionalKeyword_0_1_1_0; }
		
		//head=Call
		public Assignment getHeadAssignment_1() { return cHeadAssignment_1; }
		
		//Call
		public RuleCall getHeadCallParserRuleCall_1_0() { return cHeadCallParserRuleCall_1_0; }
		
		//":-"
		public Keyword getColonHyphenMinusKeyword_2() { return cColonHyphenMinusKeyword_2; }
		
		//body=Expression
		public Assignment getBodyAssignment_3() { return cBodyAssignment_3; }
		
		//Expression
		public RuleCall getBodyExpressionParserRuleCall_3_0() { return cBodyExpressionParserRuleCall_3_0; }
		
		//FULL_STOP
		public RuleCall getFULL_STOPTerminalRuleCall_4() { return cFULL_STOPTerminalRuleCall_4; }
	}
	public class UnnamedErrorPredicateDefintionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.UnnamedErrorPredicateDefintion");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cErrorKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cArgumentListAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cArgumentListArgumentListParserRuleCall_1_0 = (RuleCall)cArgumentListAssignment_1.eContents().get(0);
		private final Keyword cColonHyphenMinusKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cBodyAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBodyExpressionParserRuleCall_3_0 = (RuleCall)cBodyAssignment_3.eContents().get(0);
		private final RuleCall cFULL_STOPTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//UnnamedErrorPredicateDefintion:
		//	"error" argumentList=ArgumentList ":-" body=Expression FULL_STOP;
		@Override public ParserRule getRule() { return rule; }
		
		//"error" argumentList=ArgumentList ":-" body=Expression FULL_STOP
		public Group getGroup() { return cGroup; }
		
		//"error"
		public Keyword getErrorKeyword_0() { return cErrorKeyword_0; }
		
		//argumentList=ArgumentList
		public Assignment getArgumentListAssignment_1() { return cArgumentListAssignment_1; }
		
		//ArgumentList
		public RuleCall getArgumentListArgumentListParserRuleCall_1_0() { return cArgumentListArgumentListParserRuleCall_1_0; }
		
		//":-"
		public Keyword getColonHyphenMinusKeyword_2() { return cColonHyphenMinusKeyword_2; }
		
		//body=Expression
		public Assignment getBodyAssignment_3() { return cBodyAssignment_3; }
		
		//Expression
		public RuleCall getBodyExpressionParserRuleCall_3_0() { return cBodyExpressionParserRuleCall_3_0; }
		
		//FULL_STOP
		public RuleCall getFULL_STOPTerminalRuleCall_4() { return cFULL_STOPTerminalRuleCall_4; }
	}
	public class DefaultAssertionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.DefaultAssertion");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDefaultKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionCallParserRuleCall_1_0 = (RuleCall)cExpressionAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cColonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cRangeAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cRangeExpressionParserRuleCall_2_1_0 = (RuleCall)cRangeAssignment_2_1.eContents().get(0);
		private final RuleCall cFULL_STOPTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		//DefaultAssertion:
		//	"default" expression=Call (":" range=Expression)? FULL_STOP;
		@Override public ParserRule getRule() { return rule; }
		
		//"default" expression=Call (":" range=Expression)? FULL_STOP
		public Group getGroup() { return cGroup; }
		
		//"default"
		public Keyword getDefaultKeyword_0() { return cDefaultKeyword_0; }
		
		//expression=Call
		public Assignment getExpressionAssignment_1() { return cExpressionAssignment_1; }
		
		//Call
		public RuleCall getExpressionCallParserRuleCall_1_0() { return cExpressionCallParserRuleCall_1_0; }
		
		//(":" range=Expression)?
		public Group getGroup_2() { return cGroup_2; }
		
		//":"
		public Keyword getColonKeyword_2_0() { return cColonKeyword_2_0; }
		
		//range=Expression
		public Assignment getRangeAssignment_2_1() { return cRangeAssignment_2_1; }
		
		//Expression
		public RuleCall getRangeExpressionParserRuleCall_2_1_0() { return cRangeExpressionParserRuleCall_2_1_0; }
		
		//FULL_STOP
		public RuleCall getFULL_STOPTerminalRuleCall_3() { return cFULL_STOPTerminalRuleCall_3; }
	}
	public class FunctionDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.FunctionDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cResultTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cResultTypeSymbolCrossReference_0_0 = (CrossReference)cResultTypeAssignment_0.eContents().get(0);
		private final RuleCall cResultTypeSymbolQualifiedNameParserRuleCall_0_0_1 = (RuleCall)cResultTypeSymbolCrossReference_0_0.eContents().get(1);
		private final Assignment cHeadAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cHeadCallParserRuleCall_1_0 = (RuleCall)cHeadAssignment_1.eContents().get(0);
		private final Keyword cColonEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cBodyAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBodyExpressionParserRuleCall_3_0 = (RuleCall)cBodyAssignment_3.eContents().get(0);
		private final RuleCall cFULL_STOPTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//FunctionDefinition:
		//	resultType=[Symbol|QualifiedName] head=Call ":=" body=Expression FULL_STOP;
		@Override public ParserRule getRule() { return rule; }
		
		//resultType=[Symbol|QualifiedName] head=Call ":=" body=Expression FULL_STOP
		public Group getGroup() { return cGroup; }
		
		//resultType=[Symbol|QualifiedName]
		public Assignment getResultTypeAssignment_0() { return cResultTypeAssignment_0; }
		
		//[Symbol|QualifiedName]
		public CrossReference getResultTypeSymbolCrossReference_0_0() { return cResultTypeSymbolCrossReference_0_0; }
		
		//QualifiedName
		public RuleCall getResultTypeSymbolQualifiedNameParserRuleCall_0_0_1() { return cResultTypeSymbolQualifiedNameParserRuleCall_0_0_1; }
		
		//head=Call
		public Assignment getHeadAssignment_1() { return cHeadAssignment_1; }
		
		//Call
		public RuleCall getHeadCallParserRuleCall_1_0() { return cHeadCallParserRuleCall_1_0; }
		
		//":="
		public Keyword getColonEqualsSignKeyword_2() { return cColonEqualsSignKeyword_2; }
		
		//body=Expression
		public Assignment getBodyAssignment_3() { return cBodyAssignment_3; }
		
		//Expression
		public RuleCall getBodyExpressionParserRuleCall_3_0() { return cBodyExpressionParserRuleCall_3_0; }
		
		//FULL_STOP
		public RuleCall getFULL_STOPTerminalRuleCall_4() { return cFULL_STOPTerminalRuleCall_4; }
	}
	public class TypeReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.TypeReference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypeSymbolCrossReference_0_0 = (CrossReference)cTypeAssignment_0.eContents().get(0);
		private final RuleCall cTypeSymbolQualifiedNameParserRuleCall_0_0_1 = (RuleCall)cTypeSymbolCrossReference_0_0.eContents().get(1);
		private final Assignment cForceObjectTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cForceObjectTypeObjectKeyword_1_0 = (Keyword)cForceObjectTypeAssignment_1.eContents().get(0);
		
		//TypeReference:
		//	type=[Symbol|QualifiedName] forceObjectType?="object"?;
		@Override public ParserRule getRule() { return rule; }
		
		//type=[Symbol|QualifiedName] forceObjectType?="object"?
		public Group getGroup() { return cGroup; }
		
		//type=[Symbol|QualifiedName]
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//[Symbol|QualifiedName]
		public CrossReference getTypeSymbolCrossReference_0_0() { return cTypeSymbolCrossReference_0_0; }
		
		//QualifiedName
		public RuleCall getTypeSymbolQualifiedNameParserRuleCall_0_0_1() { return cTypeSymbolQualifiedNameParserRuleCall_0_0_1; }
		
		//forceObjectType?="object"?
		public Assignment getForceObjectTypeAssignment_1() { return cForceObjectTypeAssignment_1; }
		
		//"object"
		public Keyword getForceObjectTypeObjectKeyword_1_0() { return cForceObjectTypeObjectKeyword_1_0; }
	}
	public class AttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Attribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cKindAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cKindAttributeKindEnumRuleCall_0_0 = (RuleCall)cKindAssignment_0.eContents().get(0);
		private final Assignment cTargetAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cTargetSymbolCrossReference_1_0 = (CrossReference)cTargetAssignment_1.eContents().get(0);
		private final RuleCall cTargetSymbolQualifiedNameParserRuleCall_1_0_1 = (RuleCall)cTargetSymbolCrossReference_1_0.eContents().get(1);
		private final RuleCall cFULL_STOPTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//Attribute:
		//	kind=AttributeKind target=[Symbol|QualifiedName] FULL_STOP;
		@Override public ParserRule getRule() { return rule; }
		
		//kind=AttributeKind target=[Symbol|QualifiedName] FULL_STOP
		public Group getGroup() { return cGroup; }
		
		//kind=AttributeKind
		public Assignment getKindAssignment_0() { return cKindAssignment_0; }
		
		//AttributeKind
		public RuleCall getKindAttributeKindEnumRuleCall_0_0() { return cKindAttributeKindEnumRuleCall_0_0; }
		
		//target=[Symbol|QualifiedName]
		public Assignment getTargetAssignment_1() { return cTargetAssignment_1; }
		
		//[Symbol|QualifiedName]
		public CrossReference getTargetSymbolCrossReference_1_0() { return cTargetSymbolCrossReference_1_0; }
		
		//QualifiedName
		public RuleCall getTargetSymbolQualifiedNameParserRuleCall_1_0_1() { return cTargetSymbolQualifiedNameParserRuleCall_1_0_1; }
		
		//FULL_STOP
		public RuleCall getFULL_STOPTerminalRuleCall_2() { return cFULL_STOPTerminalRuleCall_2; }
	}
	public class ExternDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ExternDeclaration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cExternPredicateDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExternFunctionDeclarationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cExternAggregationOperatorDeclarationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cExternDatatypeDeclarationParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//ExternDeclaration:
		//	ExternPredicateDeclaration | ExternFunctionDeclaration | ExternAggregationOperatorDeclaration |
		//	ExternDatatypeDeclaration;
		@Override public ParserRule getRule() { return rule; }
		
		//ExternPredicateDeclaration | ExternFunctionDeclaration | ExternAggregationOperatorDeclaration |
		//ExternDatatypeDeclaration
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ExternPredicateDeclaration
		public RuleCall getExternPredicateDeclarationParserRuleCall_0() { return cExternPredicateDeclarationParserRuleCall_0; }
		
		//ExternFunctionDeclaration
		public RuleCall getExternFunctionDeclarationParserRuleCall_1() { return cExternFunctionDeclarationParserRuleCall_1; }
		
		//ExternAggregationOperatorDeclaration
		public RuleCall getExternAggregationOperatorDeclarationParserRuleCall_2() { return cExternAggregationOperatorDeclarationParserRuleCall_2; }
		
		//ExternDatatypeDeclaration
		public RuleCall getExternDatatypeDeclarationParserRuleCall_3() { return cExternDatatypeDeclarationParserRuleCall_3; }
	}
	public class ExternPredicateDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ExternPredicateDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExternKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final UnorderedGroup cUnorderedGroup_1 = (UnorderedGroup)cGroup.eContents().get(1);
		private final Assignment cFunctionalAssignment_1_0 = (Assignment)cUnorderedGroup_1.eContents().get(0);
		private final Keyword cFunctionalFunctionalKeyword_1_0_0 = (Keyword)cFunctionalAssignment_1_0.eContents().get(0);
		private final Assignment cErrorAssignment_1_1 = (Assignment)cUnorderedGroup_1.eContents().get(1);
		private final Keyword cErrorErrorKeyword_1_1_0 = (Keyword)cErrorAssignment_1_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameQualifiedNameParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Assignment cArgumentListAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cArgumentListArgumentListParserRuleCall_3_0 = (RuleCall)cArgumentListAssignment_3.eContents().get(0);
		private final RuleCall cFULL_STOPTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//ExternPredicateDeclaration:
		//	"extern" (functional?="functional"? & error?="error"?) name=QualifiedName argumentList=ArgumentList FULL_STOP;
		@Override public ParserRule getRule() { return rule; }
		
		//"extern" (functional?="functional"? & error?="error"?) name=QualifiedName argumentList=ArgumentList FULL_STOP
		public Group getGroup() { return cGroup; }
		
		//"extern"
		public Keyword getExternKeyword_0() { return cExternKeyword_0; }
		
		//functional?="functional"? & error?="error"?
		public UnorderedGroup getUnorderedGroup_1() { return cUnorderedGroup_1; }
		
		//functional?="functional"?
		public Assignment getFunctionalAssignment_1_0() { return cFunctionalAssignment_1_0; }
		
		//"functional"
		public Keyword getFunctionalFunctionalKeyword_1_0_0() { return cFunctionalFunctionalKeyword_1_0_0; }
		
		//error?="error"?
		public Assignment getErrorAssignment_1_1() { return cErrorAssignment_1_1; }
		
		//"error"
		public Keyword getErrorErrorKeyword_1_1_0() { return cErrorErrorKeyword_1_1_0; }
		
		//name=QualifiedName
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//QualifiedName
		public RuleCall getNameQualifiedNameParserRuleCall_2_0() { return cNameQualifiedNameParserRuleCall_2_0; }
		
		//argumentList=ArgumentList
		public Assignment getArgumentListAssignment_3() { return cArgumentListAssignment_3; }
		
		//ArgumentList
		public RuleCall getArgumentListArgumentListParserRuleCall_3_0() { return cArgumentListArgumentListParserRuleCall_3_0; }
		
		//FULL_STOP
		public RuleCall getFULL_STOPTerminalRuleCall_4() { return cFULL_STOPTerminalRuleCall_4; }
	}
	public class ExternFunctionDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ExternFunctionDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExternKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cResultTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cResultTypeSymbolCrossReference_1_0 = (CrossReference)cResultTypeAssignment_1.eContents().get(0);
		private final RuleCall cResultTypeSymbolQualifiedNameParserRuleCall_1_0_1 = (RuleCall)cResultTypeSymbolCrossReference_1_0.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameQualifiedNameParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Assignment cArgumentListAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cArgumentListArgumentListParserRuleCall_3_0 = (RuleCall)cArgumentListAssignment_3.eContents().get(0);
		private final RuleCall cFULL_STOPTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//ExternFunctionDeclaration:
		//	"extern" resultType=[Symbol|QualifiedName] name=QualifiedName argumentList=ArgumentList FULL_STOP;
		@Override public ParserRule getRule() { return rule; }
		
		//"extern" resultType=[Symbol|QualifiedName] name=QualifiedName argumentList=ArgumentList FULL_STOP
		public Group getGroup() { return cGroup; }
		
		//"extern"
		public Keyword getExternKeyword_0() { return cExternKeyword_0; }
		
		//resultType=[Symbol|QualifiedName]
		public Assignment getResultTypeAssignment_1() { return cResultTypeAssignment_1; }
		
		//[Symbol|QualifiedName]
		public CrossReference getResultTypeSymbolCrossReference_1_0() { return cResultTypeSymbolCrossReference_1_0; }
		
		//QualifiedName
		public RuleCall getResultTypeSymbolQualifiedNameParserRuleCall_1_0_1() { return cResultTypeSymbolQualifiedNameParserRuleCall_1_0_1; }
		
		//name=QualifiedName
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//QualifiedName
		public RuleCall getNameQualifiedNameParserRuleCall_2_0() { return cNameQualifiedNameParserRuleCall_2_0; }
		
		//argumentList=ArgumentList
		public Assignment getArgumentListAssignment_3() { return cArgumentListAssignment_3; }
		
		//ArgumentList
		public RuleCall getArgumentListArgumentListParserRuleCall_3_0() { return cArgumentListArgumentListParserRuleCall_3_0; }
		
		//FULL_STOP
		public RuleCall getFULL_STOPTerminalRuleCall_4() { return cFULL_STOPTerminalRuleCall_4; }
	}
	public class ExternAggregationOperatorDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ExternAggregationOperatorDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExternKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cResultTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cResultTypeSymbolCrossReference_1_0 = (CrossReference)cResultTypeAssignment_1.eContents().get(0);
		private final RuleCall cResultTypeSymbolQualifiedNameParserRuleCall_1_0_1 = (RuleCall)cResultTypeSymbolCrossReference_1_0.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameQualifiedNameParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cArgumentTypeAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final CrossReference cArgumentTypeSymbolCrossReference_4_0 = (CrossReference)cArgumentTypeAssignment_4.eContents().get(0);
		private final RuleCall cArgumentTypeSymbolQualifiedNameParserRuleCall_4_0_1 = (RuleCall)cArgumentTypeSymbolCrossReference_4_0.eContents().get(1);
		private final Keyword cFullStopFullStopFullStopKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final RuleCall cFULL_STOPTerminalRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		
		//ExternAggregationOperatorDeclaration:
		//	"extern" resultType=[Symbol|QualifiedName] name=QualifiedName "{" argumentType=[Symbol|QualifiedName] "..." "}"
		//	FULL_STOP;
		@Override public ParserRule getRule() { return rule; }
		
		//"extern" resultType=[Symbol|QualifiedName] name=QualifiedName "{" argumentType=[Symbol|QualifiedName] "..." "}"
		//FULL_STOP
		public Group getGroup() { return cGroup; }
		
		//"extern"
		public Keyword getExternKeyword_0() { return cExternKeyword_0; }
		
		//resultType=[Symbol|QualifiedName]
		public Assignment getResultTypeAssignment_1() { return cResultTypeAssignment_1; }
		
		//[Symbol|QualifiedName]
		public CrossReference getResultTypeSymbolCrossReference_1_0() { return cResultTypeSymbolCrossReference_1_0; }
		
		//QualifiedName
		public RuleCall getResultTypeSymbolQualifiedNameParserRuleCall_1_0_1() { return cResultTypeSymbolQualifiedNameParserRuleCall_1_0_1; }
		
		//name=QualifiedName
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//QualifiedName
		public RuleCall getNameQualifiedNameParserRuleCall_2_0() { return cNameQualifiedNameParserRuleCall_2_0; }
		
		//"{"
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }
		
		//argumentType=[Symbol|QualifiedName]
		public Assignment getArgumentTypeAssignment_4() { return cArgumentTypeAssignment_4; }
		
		//[Symbol|QualifiedName]
		public CrossReference getArgumentTypeSymbolCrossReference_4_0() { return cArgumentTypeSymbolCrossReference_4_0; }
		
		//QualifiedName
		public RuleCall getArgumentTypeSymbolQualifiedNameParserRuleCall_4_0_1() { return cArgumentTypeSymbolQualifiedNameParserRuleCall_4_0_1; }
		
		//"..."
		public Keyword getFullStopFullStopFullStopKeyword_5() { return cFullStopFullStopFullStopKeyword_5; }
		
		//"}"
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
		
		//FULL_STOP
		public RuleCall getFULL_STOPTerminalRuleCall_7() { return cFULL_STOPTerminalRuleCall_7; }
	}
	public class ExternDatatypeDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ExternDatatypeDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExternKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cDatatypeKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameQualifiedNameParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final RuleCall cFULL_STOPTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		//ExternDatatypeDeclaration:
		//	"extern" "datatype" name=QualifiedName FULL_STOP;
		@Override public ParserRule getRule() { return rule; }
		
		//"extern" "datatype" name=QualifiedName FULL_STOP
		public Group getGroup() { return cGroup; }
		
		//"extern"
		public Keyword getExternKeyword_0() { return cExternKeyword_0; }
		
		//"datatype"
		public Keyword getDatatypeKeyword_1() { return cDatatypeKeyword_1; }
		
		//name=QualifiedName
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//QualifiedName
		public RuleCall getNameQualifiedNameParserRuleCall_2_0() { return cNameQualifiedNameParserRuleCall_2_0; }
		
		//FULL_STOP
		public RuleCall getFULL_STOPTerminalRuleCall_3() { return cFULL_STOPTerminalRuleCall_3; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cConditionalExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLetExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final RuleCall cDisjunctiveExpressionParserRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Action cForallConditionAction_2_1_0 = (Action)cGroup_2_1.eContents().get(0);
		private final Keyword cEqualsSignGreaterThanSignKeyword_2_1_1 = (Keyword)cGroup_2_1.eContents().get(1);
		private final Assignment cBodyAssignment_2_1_2 = (Assignment)cGroup_2_1.eContents().get(2);
		private final RuleCall cBodyDisjunctiveExpressionParserRuleCall_2_1_2_0 = (RuleCall)cBodyAssignment_2_1_2.eContents().get(0);
		
		//Expression:
		//	ConditionalExpression | LetExpression | DisjunctiveExpression ({Forall.condition=current} "=>"
		//	body=DisjunctiveExpression)?;
		@Override public ParserRule getRule() { return rule; }
		
		//ConditionalExpression | LetExpression | DisjunctiveExpression ({Forall.condition=current} "=>"
		//body=DisjunctiveExpression)?
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ConditionalExpression
		public RuleCall getConditionalExpressionParserRuleCall_0() { return cConditionalExpressionParserRuleCall_0; }
		
		//LetExpression
		public RuleCall getLetExpressionParserRuleCall_1() { return cLetExpressionParserRuleCall_1; }
		
		//DisjunctiveExpression ({Forall.condition=current} "=>" body=DisjunctiveExpression)?
		public Group getGroup_2() { return cGroup_2; }
		
		//DisjunctiveExpression
		public RuleCall getDisjunctiveExpressionParserRuleCall_2_0() { return cDisjunctiveExpressionParserRuleCall_2_0; }
		
		//({Forall.condition=current} "=>" body=DisjunctiveExpression)?
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//{Forall.condition=current}
		public Action getForallConditionAction_2_1_0() { return cForallConditionAction_2_1_0; }
		
		//"=>"
		public Keyword getEqualsSignGreaterThanSignKeyword_2_1_1() { return cEqualsSignGreaterThanSignKeyword_2_1_1; }
		
		//body=DisjunctiveExpression
		public Assignment getBodyAssignment_2_1_2() { return cBodyAssignment_2_1_2; }
		
		//DisjunctiveExpression
		public RuleCall getBodyDisjunctiveExpressionParserRuleCall_2_1_2_0() { return cBodyDisjunctiveExpressionParserRuleCall_2_1_2_0; }
	}
	public class ConditionalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ConditionalExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConditionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConditionDisjunctiveExpressionParserRuleCall_1_0 = (RuleCall)cConditionAssignment_1.eContents().get(0);
		private final Keyword cThenKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cThenAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cThenExpressionParserRuleCall_3_0 = (RuleCall)cThenAssignment_3.eContents().get(0);
		private final Keyword cElseKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cElseAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cElseExpressionParserRuleCall_5_0 = (RuleCall)cElseAssignment_5.eContents().get(0);
		
		//ConditionalExpression:
		//	"if" condition=DisjunctiveExpression "then" then=Expression "else" else=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//"if" condition=DisjunctiveExpression "then" then=Expression "else" else=Expression
		public Group getGroup() { return cGroup; }
		
		//"if"
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }
		
		//condition=DisjunctiveExpression
		public Assignment getConditionAssignment_1() { return cConditionAssignment_1; }
		
		//DisjunctiveExpression
		public RuleCall getConditionDisjunctiveExpressionParserRuleCall_1_0() { return cConditionDisjunctiveExpressionParserRuleCall_1_0; }
		
		//"then"
		public Keyword getThenKeyword_2() { return cThenKeyword_2; }
		
		//then=Expression
		public Assignment getThenAssignment_3() { return cThenAssignment_3; }
		
		//Expression
		public RuleCall getThenExpressionParserRuleCall_3_0() { return cThenExpressionParserRuleCall_3_0; }
		
		//"else"
		public Keyword getElseKeyword_4() { return cElseKeyword_4; }
		
		//else=Expression
		public Assignment getElseAssignment_5() { return cElseAssignment_5; }
		
		//Expression
		public RuleCall getElseExpressionParserRuleCall_5_0() { return cElseExpressionParserRuleCall_5_0; }
	}
	public class LetExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.LetExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLetKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cBindingsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBindingsLetBindingParserRuleCall_1_0 = (RuleCall)cBindingsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cBindingsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cBindingsLetBindingParserRuleCall_2_1_0 = (RuleCall)cBindingsAssignment_2_1.eContents().get(0);
		private final Keyword cInKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cBodyAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBodyExpressionParserRuleCall_4_0 = (RuleCall)cBodyAssignment_4.eContents().get(0);
		
		//LetExpression:
		//	"let" bindings+=LetBinding ("," bindings+=LetBinding)* "in" body=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//"let" bindings+=LetBinding ("," bindings+=LetBinding)* "in" body=Expression
		public Group getGroup() { return cGroup; }
		
		//"let"
		public Keyword getLetKeyword_0() { return cLetKeyword_0; }
		
		//bindings+=LetBinding
		public Assignment getBindingsAssignment_1() { return cBindingsAssignment_1; }
		
		//LetBinding
		public RuleCall getBindingsLetBindingParserRuleCall_1_0() { return cBindingsLetBindingParserRuleCall_1_0; }
		
		//("," bindings+=LetBinding)*
		public Group getGroup_2() { return cGroup_2; }
		
		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//bindings+=LetBinding
		public Assignment getBindingsAssignment_2_1() { return cBindingsAssignment_2_1; }
		
		//LetBinding
		public RuleCall getBindingsLetBindingParserRuleCall_2_1_0() { return cBindingsLetBindingParserRuleCall_2_1_0; }
		
		//"in"
		public Keyword getInKeyword_3() { return cInKeyword_3; }
		
		//body=Expression
		public Assignment getBodyAssignment_4() { return cBodyAssignment_4; }
		
		//Expression
		public RuleCall getBodyExpressionParserRuleCall_4_0() { return cBodyExpressionParserRuleCall_4_0; }
	}
	public class LetBindingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.LetBinding");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypeSymbolCrossReference_0_0 = (CrossReference)cTypeAssignment_0.eContents().get(0);
		private final RuleCall cTypeSymbolQualifiedNameParserRuleCall_0_0_1 = (RuleCall)cTypeSymbolCrossReference_0_0.eContents().get(1);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cValueAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValueAdditiveExpressionParserRuleCall_3_0 = (RuleCall)cValueAssignment_3.eContents().get(0);
		
		//LetBinding:
		//	type=[Symbol|QualifiedName]? name=ID "=" value=AdditiveExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//type=[Symbol|QualifiedName]? name=ID "=" value=AdditiveExpression
		public Group getGroup() { return cGroup; }
		
		//type=[Symbol|QualifiedName]?
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//[Symbol|QualifiedName]
		public CrossReference getTypeSymbolCrossReference_0_0() { return cTypeSymbolCrossReference_0_0; }
		
		//QualifiedName
		public RuleCall getTypeSymbolQualifiedNameParserRuleCall_0_0_1() { return cTypeSymbolQualifiedNameParserRuleCall_0_0_1; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }
		
		//value=AdditiveExpression
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }
		
		//AdditiveExpression
		public RuleCall getValueAdditiveExpressionParserRuleCall_3_0() { return cValueAdditiveExpressionParserRuleCall_3_0; }
	}
	public class DisjunctiveExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.DisjunctiveExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cConjunctiveExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Action cDisjunctionChildrenAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Group cGroup_1_0_1 = (Group)cGroup_1_0.eContents().get(1);
		private final Keyword cSemicolonKeyword_1_0_1_0 = (Keyword)cGroup_1_0_1.eContents().get(0);
		private final Assignment cChildrenAssignment_1_0_1_1 = (Assignment)cGroup_1_0_1.eContents().get(1);
		private final RuleCall cChildrenConjunctiveExpressionParserRuleCall_1_0_1_1_0 = (RuleCall)cChildrenAssignment_1_0_1_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Action cCaseConditionAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		private final Assignment cBodyAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cBodyConjunctiveExpressionParserRuleCall_1_1_2_0 = (RuleCall)cBodyAssignment_1_1_2.eContents().get(0);
		private final Action cSwitchCasesAction_1_1_3 = (Action)cGroup_1_1.eContents().get(3);
		private final Group cGroup_1_1_4 = (Group)cGroup_1_1.eContents().get(4);
		private final Keyword cSemicolonKeyword_1_1_4_0 = (Keyword)cGroup_1_1_4.eContents().get(0);
		private final Assignment cCasesAssignment_1_1_4_1 = (Assignment)cGroup_1_1_4.eContents().get(1);
		private final RuleCall cCasesCaseParserRuleCall_1_1_4_1_0 = (RuleCall)cCasesAssignment_1_1_4_1.eContents().get(0);
		
		//DisjunctiveExpression Expression:
		//	ConjunctiveExpression ({Disjunction.children+=current} (";" children+=ConjunctiveExpression)+ |
		//	{Case.condition=current} "->" body=ConjunctiveExpression {Switch.cases+=current} (";" cases+=Case)*)?;
		@Override public ParserRule getRule() { return rule; }
		
		//ConjunctiveExpression ({Disjunction.children+=current} (";" children+=ConjunctiveExpression)+ | {Case.condition=current}
		//"->" body=ConjunctiveExpression {Switch.cases+=current} (";" cases+=Case)*)?
		public Group getGroup() { return cGroup; }
		
		//ConjunctiveExpression
		public RuleCall getConjunctiveExpressionParserRuleCall_0() { return cConjunctiveExpressionParserRuleCall_0; }
		
		//({Disjunction.children+=current} (";" children+=ConjunctiveExpression)+ | {Case.condition=current} "->"
		//body=ConjunctiveExpression {Switch.cases+=current} (";" cases+=Case)*)?
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//{Disjunction.children+=current} (";" children+=ConjunctiveExpression)+
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{Disjunction.children+=current}
		public Action getDisjunctionChildrenAction_1_0_0() { return cDisjunctionChildrenAction_1_0_0; }
		
		//(";" children+=ConjunctiveExpression)+
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }
		
		//";"
		public Keyword getSemicolonKeyword_1_0_1_0() { return cSemicolonKeyword_1_0_1_0; }
		
		//children+=ConjunctiveExpression
		public Assignment getChildrenAssignment_1_0_1_1() { return cChildrenAssignment_1_0_1_1; }
		
		//ConjunctiveExpression
		public RuleCall getChildrenConjunctiveExpressionParserRuleCall_1_0_1_1_0() { return cChildrenConjunctiveExpressionParserRuleCall_1_0_1_1_0; }
		
		//{Case.condition=current} "->" body=ConjunctiveExpression {Switch.cases+=current} (";" cases+=Case)*
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//{Case.condition=current}
		public Action getCaseConditionAction_1_1_0() { return cCaseConditionAction_1_1_0; }
		
		//"->"
		public Keyword getHyphenMinusGreaterThanSignKeyword_1_1_1() { return cHyphenMinusGreaterThanSignKeyword_1_1_1; }
		
		//body=ConjunctiveExpression
		public Assignment getBodyAssignment_1_1_2() { return cBodyAssignment_1_1_2; }
		
		//ConjunctiveExpression
		public RuleCall getBodyConjunctiveExpressionParserRuleCall_1_1_2_0() { return cBodyConjunctiveExpressionParserRuleCall_1_1_2_0; }
		
		//{Switch.cases+=current}
		public Action getSwitchCasesAction_1_1_3() { return cSwitchCasesAction_1_1_3; }
		
		//(";" cases+=Case)*
		public Group getGroup_1_1_4() { return cGroup_1_1_4; }
		
		//";"
		public Keyword getSemicolonKeyword_1_1_4_0() { return cSemicolonKeyword_1_1_4_0; }
		
		//cases+=Case
		public Assignment getCasesAssignment_1_1_4_1() { return cCasesAssignment_1_1_4_1; }
		
		//Case
		public RuleCall getCasesCaseParserRuleCall_1_1_4_1_0() { return cCasesCaseParserRuleCall_1_1_4_1_0; }
	}
	public class CaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Case");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cConditionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cConditionConjunctiveExpressionParserRuleCall_0_0 = (RuleCall)cConditionAssignment_0.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cBodyAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBodyConjunctiveExpressionParserRuleCall_2_0 = (RuleCall)cBodyAssignment_2.eContents().get(0);
		
		//Case:
		//	condition=ConjunctiveExpression "->" body=ConjunctiveExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//condition=ConjunctiveExpression "->" body=ConjunctiveExpression
		public Group getGroup() { return cGroup; }
		
		//condition=ConjunctiveExpression
		public Assignment getConditionAssignment_0() { return cConditionAssignment_0; }
		
		//ConjunctiveExpression
		public RuleCall getConditionConjunctiveExpressionParserRuleCall_0_0() { return cConditionConjunctiveExpressionParserRuleCall_0_0; }
		
		//"->"
		public Keyword getHyphenMinusGreaterThanSignKeyword_1() { return cHyphenMinusGreaterThanSignKeyword_1; }
		
		//body=ConjunctiveExpression
		public Assignment getBodyAssignment_2() { return cBodyAssignment_2; }
		
		//ConjunctiveExpression
		public RuleCall getBodyConjunctiveExpressionParserRuleCall_2_0() { return cBodyConjunctiveExpressionParserRuleCall_2_0; }
	}
	public class ConjunctiveExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ConjunctiveExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cConjunctionChildrenAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cCommaKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cChildrenAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cChildrenComparisonExpressionParserRuleCall_1_1_1_0 = (RuleCall)cChildrenAssignment_1_1_1.eContents().get(0);
		
		//ConjunctiveExpression Expression:
		//	ComparisonExpression ({Conjunction.children+=current} ("," children+=ComparisonExpression)+)?;
		@Override public ParserRule getRule() { return rule; }
		
		//ComparisonExpression ({Conjunction.children+=current} ("," children+=ComparisonExpression)+)?
		public Group getGroup() { return cGroup; }
		
		//ComparisonExpression
		public RuleCall getComparisonExpressionParserRuleCall_0() { return cComparisonExpressionParserRuleCall_0; }
		
		//({Conjunction.children+=current} ("," children+=ComparisonExpression)+)?
		public Group getGroup_1() { return cGroup_1; }
		
		//{Conjunction.children+=current}
		public Action getConjunctionChildrenAction_1_0() { return cConjunctionChildrenAction_1_0; }
		
		//("," children+=ComparisonExpression)+
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//","
		public Keyword getCommaKeyword_1_1_0() { return cCommaKeyword_1_1_0; }
		
		//children+=ComparisonExpression
		public Assignment getChildrenAssignment_1_1_1() { return cChildrenAssignment_1_1_1; }
		
		//ComparisonExpression
		public RuleCall getChildrenComparisonExpressionParserRuleCall_1_1_1_0() { return cChildrenComparisonExpressionParserRuleCall_1_1_1_0; }
	}
	public class ComparisonExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ComparisonExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdditiveExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpComparisonOperatorEnumRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAdditiveExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//ComparisonExpression Expression:
		//	AdditiveExpression ({BinaryExpression.left=current} op=ComparisonOperator right=AdditiveExpression)?;
		@Override public ParserRule getRule() { return rule; }
		
		//AdditiveExpression ({BinaryExpression.left=current} op=ComparisonOperator right=AdditiveExpression)?
		public Group getGroup() { return cGroup; }
		
		//AdditiveExpression
		public RuleCall getAdditiveExpressionParserRuleCall_0() { return cAdditiveExpressionParserRuleCall_0; }
		
		//({BinaryExpression.left=current} op=ComparisonOperator right=AdditiveExpression)?
		public Group getGroup_1() { return cGroup_1; }
		
		//{BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }
		
		//op=ComparisonOperator
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//ComparisonOperator
		public RuleCall getOpComparisonOperatorEnumRuleCall_1_1_0() { return cOpComparisonOperatorEnumRuleCall_1_1_0; }
		
		//right=AdditiveExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//AdditiveExpression
		public RuleCall getRightAdditiveExpressionParserRuleCall_1_2_0() { return cRightAdditiveExpressionParserRuleCall_1_2_0; }
	}
	public class AdditiveExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.AdditiveExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicativeExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpAdditiveBinaryOperatorEnumRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightMultiplicativeExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//AdditiveExpression Expression:
		//	MultiplicativeExpression ({BinaryExpression.left=current} op=AdditiveBinaryOperator right=MultiplicativeExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//MultiplicativeExpression ({BinaryExpression.left=current} op=AdditiveBinaryOperator right=MultiplicativeExpression)*
		public Group getGroup() { return cGroup; }
		
		//MultiplicativeExpression
		public RuleCall getMultiplicativeExpressionParserRuleCall_0() { return cMultiplicativeExpressionParserRuleCall_0; }
		
		//({BinaryExpression.left=current} op=AdditiveBinaryOperator right=MultiplicativeExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }
		
		//op=AdditiveBinaryOperator
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//AdditiveBinaryOperator
		public RuleCall getOpAdditiveBinaryOperatorEnumRuleCall_1_1_0() { return cOpAdditiveBinaryOperatorEnumRuleCall_1_1_0; }
		
		//right=MultiplicativeExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//MultiplicativeExpression
		public RuleCall getRightMultiplicativeExpressionParserRuleCall_1_2_0() { return cRightMultiplicativeExpressionParserRuleCall_1_2_0; }
	}
	public class MultiplicativeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.MultiplicativeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExponentialExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpMultiplicativeBinaryOperatorEnumRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExponentialExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//MultiplicativeExpression Expression:
		//	ExponentialExpression ({BinaryExpression.left=current} op=MultiplicativeBinaryOperator right=ExponentialExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//ExponentialExpression ({BinaryExpression.left=current} op=MultiplicativeBinaryOperator right=ExponentialExpression)*
		public Group getGroup() { return cGroup; }
		
		//ExponentialExpression
		public RuleCall getExponentialExpressionParserRuleCall_0() { return cExponentialExpressionParserRuleCall_0; }
		
		//({BinaryExpression.left=current} op=MultiplicativeBinaryOperator right=ExponentialExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }
		
		//op=MultiplicativeBinaryOperator
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//MultiplicativeBinaryOperator
		public RuleCall getOpMultiplicativeBinaryOperatorEnumRuleCall_1_1_0() { return cOpMultiplicativeBinaryOperatorEnumRuleCall_1_1_0; }
		
		//right=ExponentialExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//ExponentialExpression
		public RuleCall getRightExponentialExpressionParserRuleCall_1_2_0() { return cRightExponentialExpressionParserRuleCall_1_2_0; }
	}
	public class ExponentialExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ExponentialExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cCastExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpExponentialOpEnumRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightCastExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//ExponentialExpression Expression:
		//	CastExpression ({BinaryExpression.left=current} op=ExponentialOp right=CastExpression)?;
		@Override public ParserRule getRule() { return rule; }
		
		//CastExpression ({BinaryExpression.left=current} op=ExponentialOp right=CastExpression)?
		public Group getGroup() { return cGroup; }
		
		//CastExpression
		public RuleCall getCastExpressionParserRuleCall_0() { return cCastExpressionParserRuleCall_0; }
		
		//({BinaryExpression.left=current} op=ExponentialOp right=CastExpression)?
		public Group getGroup_1() { return cGroup_1; }
		
		//{BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }
		
		//op=ExponentialOp
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//ExponentialOp
		public RuleCall getOpExponentialOpEnumRuleCall_1_1_0() { return cOpExponentialOpEnumRuleCall_1_1_0; }
		
		//right=CastExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//CastExpression
		public RuleCall getRightCastExpressionParserRuleCall_1_2_0() { return cRightCastExpressionParserRuleCall_1_2_0; }
	}
	public class CastExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.CastExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cCastExpressionBodyAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAsKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cTargetTypeAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final CrossReference cTargetTypeSymbolCrossReference_1_2_0 = (CrossReference)cTargetTypeAssignment_1_2.eContents().get(0);
		private final RuleCall cTargetTypeSymbolQualifiedNameParserRuleCall_1_2_0_1 = (RuleCall)cTargetTypeSymbolCrossReference_1_2_0.eContents().get(1);
		
		//CastExpression Expression:
		//	UnaryExpression ({CastExpression.body=current} "as" targetType=[Symbol|QualifiedName])?;
		@Override public ParserRule getRule() { return rule; }
		
		//UnaryExpression ({CastExpression.body=current} "as" targetType=[Symbol|QualifiedName])?
		public Group getGroup() { return cGroup; }
		
		//UnaryExpression
		public RuleCall getUnaryExpressionParserRuleCall_0() { return cUnaryExpressionParserRuleCall_0; }
		
		//({CastExpression.body=current} "as" targetType=[Symbol|QualifiedName])?
		public Group getGroup_1() { return cGroup_1; }
		
		//{CastExpression.body=current}
		public Action getCastExpressionBodyAction_1_0() { return cCastExpressionBodyAction_1_0; }
		
		//"as"
		public Keyword getAsKeyword_1_1() { return cAsKeyword_1_1; }
		
		//targetType=[Symbol|QualifiedName]
		public Assignment getTargetTypeAssignment_1_2() { return cTargetTypeAssignment_1_2; }
		
		//[Symbol|QualifiedName]
		public CrossReference getTargetTypeSymbolCrossReference_1_2_0() { return cTargetTypeSymbolCrossReference_1_2_0; }
		
		//QualifiedName
		public RuleCall getTargetTypeSymbolQualifiedNameParserRuleCall_1_2_0_1() { return cTargetTypeSymbolQualifiedNameParserRuleCall_1_2_0_1; }
	}
	public class UnaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.UnaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBracedAggregateExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cUnaryExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpUnaryOperatorEnumRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cBodyAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cBodyBracedAggregateExpressionParserRuleCall_1_2_0 = (RuleCall)cBodyAssignment_1_2.eContents().get(0);
		
		//UnaryExpression Expression:
		//	BracedAggregateExpression | {UnaryExpression} op=UnaryOperator body=BracedAggregateExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//BracedAggregateExpression | {UnaryExpression} op=UnaryOperator body=BracedAggregateExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//BracedAggregateExpression
		public RuleCall getBracedAggregateExpressionParserRuleCall_0() { return cBracedAggregateExpressionParserRuleCall_0; }
		
		//{UnaryExpression} op=UnaryOperator body=BracedAggregateExpression
		public Group getGroup_1() { return cGroup_1; }
		
		//{UnaryExpression}
		public Action getUnaryExpressionAction_1_0() { return cUnaryExpressionAction_1_0; }
		
		//op=UnaryOperator
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//UnaryOperator
		public RuleCall getOpUnaryOperatorEnumRuleCall_1_1_0() { return cOpUnaryOperatorEnumRuleCall_1_1_0; }
		
		//body=BracedAggregateExpression
		public Assignment getBodyAssignment_1_2() { return cBodyAssignment_1_2; }
		
		//BracedAggregateExpression
		public RuleCall getBodyBracedAggregateExpressionParserRuleCall_1_2_0() { return cBodyBracedAggregateExpressionParserRuleCall_1_2_0; }
	}
	public class BracedAggregateExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.BracedAggregateExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAtomicExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAggregationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cCountParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//BracedAggregateExpression Expression:
		//	AtomicExpression | Aggregation | Count;
		@Override public ParserRule getRule() { return rule; }
		
		//AtomicExpression | Aggregation | Count
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//AtomicExpression
		public RuleCall getAtomicExpressionParserRuleCall_0() { return cAtomicExpressionParserRuleCall_0; }
		
		//Aggregation
		public RuleCall getAggregationParserRuleCall_1() { return cAggregationParserRuleCall_1; }
		
		//Count
		public RuleCall getCountParserRuleCall_2() { return cCountParserRuleCall_2; }
	}
	public class AggregationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Aggregation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cOpSymbolCrossReference_0_0 = (CrossReference)cOpAssignment_0.eContents().get(0);
		private final RuleCall cOpSymbolQualifiedNameParserRuleCall_0_0_1 = (RuleCall)cOpSymbolCrossReference_0_0.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueExpressionParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		private final Keyword cVerticalLineKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cConditionAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cConditionExpressionParserRuleCall_4_0 = (RuleCall)cConditionAssignment_4.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Aggregation:
		//	op=[Symbol|QualifiedName] "{" value=Expression "|" condition=Expression "}";
		@Override public ParserRule getRule() { return rule; }
		
		//op=[Symbol|QualifiedName] "{" value=Expression "|" condition=Expression "}"
		public Group getGroup() { return cGroup; }
		
		//op=[Symbol|QualifiedName]
		public Assignment getOpAssignment_0() { return cOpAssignment_0; }
		
		//[Symbol|QualifiedName]
		public CrossReference getOpSymbolCrossReference_0_0() { return cOpSymbolCrossReference_0_0; }
		
		//QualifiedName
		public RuleCall getOpSymbolQualifiedNameParserRuleCall_0_0_1() { return cOpSymbolQualifiedNameParserRuleCall_0_0_1; }
		
		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//value=Expression
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }
		
		//Expression
		public RuleCall getValueExpressionParserRuleCall_2_0() { return cValueExpressionParserRuleCall_2_0; }
		
		//"|"
		public Keyword getVerticalLineKeyword_3() { return cVerticalLineKeyword_3; }
		
		//condition=Expression
		public Assignment getConditionAssignment_4() { return cConditionAssignment_4; }
		
		//Expression
		public RuleCall getConditionExpressionParserRuleCall_4_0() { return cConditionExpressionParserRuleCall_4_0; }
		
		//"}"
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}
	public class CountElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Count");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCountKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cConditionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConditionExpressionParserRuleCall_2_0 = (RuleCall)cConditionAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Count:
		//	"count" "{" condition=Expression "}";
		@Override public ParserRule getRule() { return rule; }
		
		//"count" "{" condition=Expression "}"
		public Group getGroup() { return cGroup; }
		
		//"count"
		public Keyword getCountKeyword_0() { return cCountKeyword_0; }
		
		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//condition=Expression
		public Assignment getConditionAssignment_2() { return cConditionAssignment_2; }
		
		//Expression
		public RuleCall getConditionExpressionParserRuleCall_2_0() { return cConditionExpressionParserRuleCall_2_0; }
		
		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}
	public class AtomicExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.AtomicExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cReferenceParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCallParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cIntervalParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cLiteralParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Keyword cLeftParenthesisKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_4_2 = (Keyword)cGroup_4.eContents().get(2);
		
		//AtomicExpression Expression:
		//	Reference | Call | Interval | Literal | "(" Expression ")";
		@Override public ParserRule getRule() { return rule; }
		
		//Reference | Call | Interval | Literal | "(" Expression ")"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Reference
		public RuleCall getReferenceParserRuleCall_0() { return cReferenceParserRuleCall_0; }
		
		//Call
		public RuleCall getCallParserRuleCall_1() { return cCallParserRuleCall_1; }
		
		//Interval
		public RuleCall getIntervalParserRuleCall_2() { return cIntervalParserRuleCall_2; }
		
		//Literal
		public RuleCall getLiteralParserRuleCall_3() { return cLiteralParserRuleCall_3; }
		
		//"(" Expression ")"
		public Group getGroup_4() { return cGroup_4; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_4_0() { return cLeftParenthesisKeyword_4_0; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_4_1() { return cExpressionParserRuleCall_4_1; }
		
		//")"
		public Keyword getRightParenthesisKeyword_4_2() { return cRightParenthesisKeyword_4_2; }
	}
	public class CallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Call");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFunctorAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFunctorReferenceParserRuleCall_0_0 = (RuleCall)cFunctorAssignment_0.eContents().get(0);
		private final Assignment cArgumentListAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cArgumentListArgumentListParserRuleCall_1_0 = (RuleCall)cArgumentListAssignment_1.eContents().get(0);
		
		//Call:
		//	functor=Reference argumentList=ArgumentList;
		@Override public ParserRule getRule() { return rule; }
		
		//functor=Reference argumentList=ArgumentList
		public Group getGroup() { return cGroup; }
		
		//functor=Reference
		public Assignment getFunctorAssignment_0() { return cFunctorAssignment_0; }
		
		//Reference
		public RuleCall getFunctorReferenceParserRuleCall_0_0() { return cFunctorReferenceParserRuleCall_0_0; }
		
		//argumentList=ArgumentList
		public Assignment getArgumentListAssignment_1() { return cArgumentListAssignment_1; }
		
		//ArgumentList
		public RuleCall getArgumentListArgumentListParserRuleCall_1_0() { return cArgumentListArgumentListParserRuleCall_1_0; }
	}
	public class ArgumentListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ArgumentList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cArgumentListAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cArgumentsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cArgumentsArgumentParserRuleCall_2_0_0 = (RuleCall)cArgumentsAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cArgumentsAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cArgumentsArgumentParserRuleCall_2_1_1_0 = (RuleCall)cArgumentsAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ArgumentList:
		//	{ArgumentList} "(" (arguments+=Argument ("," arguments+=Argument)*)? ")";
		@Override public ParserRule getRule() { return rule; }
		
		//{ArgumentList} "(" (arguments+=Argument ("," arguments+=Argument)*)? ")"
		public Group getGroup() { return cGroup; }
		
		//{ArgumentList}
		public Action getArgumentListAction_0() { return cArgumentListAction_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//(arguments+=Argument ("," arguments+=Argument)*)?
		public Group getGroup_2() { return cGroup_2; }
		
		//arguments+=Argument
		public Assignment getArgumentsAssignment_2_0() { return cArgumentsAssignment_2_0; }
		
		//Argument
		public RuleCall getArgumentsArgumentParserRuleCall_2_0_0() { return cArgumentsArgumentParserRuleCall_2_0_0; }
		
		//("," arguments+=Argument)*
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }
		
		//arguments+=Argument
		public Assignment getArgumentsAssignment_2_1_1() { return cArgumentsAssignment_2_1_1; }
		
		//Argument
		public RuleCall getArgumentsArgumentParserRuleCall_2_1_1_0() { return cArgumentsArgumentParserRuleCall_2_1_1_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class ArgumentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Argument");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cExpressionArgumentParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStarArgumentParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cTypedVariableArgumentParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cTypedStarArgumentParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//Argument:
		//	ExpressionArgument | StarArgument | TypedVariableArgument | TypedStarArgument;
		@Override public ParserRule getRule() { return rule; }
		
		//ExpressionArgument | StarArgument | TypedVariableArgument | TypedStarArgument
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ExpressionArgument
		public RuleCall getExpressionArgumentParserRuleCall_0() { return cExpressionArgumentParserRuleCall_0; }
		
		//StarArgument
		public RuleCall getStarArgumentParserRuleCall_1() { return cStarArgumentParserRuleCall_1; }
		
		//TypedVariableArgument
		public RuleCall getTypedVariableArgumentParserRuleCall_2() { return cTypedVariableArgumentParserRuleCall_2; }
		
		//TypedStarArgument
		public RuleCall getTypedStarArgumentParserRuleCall_3() { return cTypedStarArgumentParserRuleCall_3; }
	}
	public class ExpressionArgumentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ExpressionArgument");
		private final Assignment cExpressionAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cExpressionComparisonExpressionParserRuleCall_0 = (RuleCall)cExpressionAssignment.eContents().get(0);
		
		//ExpressionArgument:
		//	expression=ComparisonExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//expression=ComparisonExpression
		public Assignment getExpressionAssignment() { return cExpressionAssignment; }
		
		//ComparisonExpression
		public RuleCall getExpressionComparisonExpressionParserRuleCall_0() { return cExpressionComparisonExpressionParserRuleCall_0; }
	}
	public class StarArgumentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.StarArgument");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cStarArgumentAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cAsteriskKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//StarArgument:
		//	{StarArgument} "*";
		@Override public ParserRule getRule() { return rule; }
		
		//{StarArgument} "*"
		public Group getGroup() { return cGroup; }
		
		//{StarArgument}
		public Action getStarArgumentAction_0() { return cStarArgumentAction_0; }
		
		//"*"
		public Keyword getAsteriskKeyword_1() { return cAsteriskKeyword_1; }
	}
	public class TypedVariableArgumentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.TypedVariableArgument");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeReferenceAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeReferenceTypeReferenceParserRuleCall_0_0 = (RuleCall)cTypeReferenceAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//TypedVariableArgument:
		//	typeReference=TypeReference name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//typeReference=TypeReference name=ID
		public Group getGroup() { return cGroup; }
		
		//typeReference=TypeReference
		public Assignment getTypeReferenceAssignment_0() { return cTypeReferenceAssignment_0; }
		
		//TypeReference
		public RuleCall getTypeReferenceTypeReferenceParserRuleCall_0_0() { return cTypeReferenceTypeReferenceParserRuleCall_0_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}
	public class TypedStarArgumentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.TypedStarArgument");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeReferenceAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeReferenceTypeReferenceParserRuleCall_0_0 = (RuleCall)cTypeReferenceAssignment_0.eContents().get(0);
		private final Keyword cAsteriskKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//TypedStarArgument:
		//	typeReference=TypeReference "*";
		@Override public ParserRule getRule() { return rule; }
		
		//typeReference=TypeReference "*"
		public Group getGroup() { return cGroup; }
		
		//typeReference=TypeReference
		public Assignment getTypeReferenceAssignment_0() { return cTypeReferenceAssignment_0; }
		
		//TypeReference
		public RuleCall getTypeReferenceTypeReferenceParserRuleCall_0_0() { return cTypeReferenceTypeReferenceParserRuleCall_0_0; }
		
		//"*"
		public Keyword getAsteriskKeyword_1() { return cAsteriskKeyword_1; }
	}
	public class ReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Reference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cComponentsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cComponentsPathComponentParserRuleCall_0_0 = (RuleCall)cComponentsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cComponentsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cComponentsPathComponentParserRuleCall_1_1_0 = (RuleCall)cComponentsAssignment_1_1.eContents().get(0);
		
		//Reference:
		//	components+=PathComponent ("." components+=PathComponent)*;
		@Override public ParserRule getRule() { return rule; }
		
		//components+=PathComponent ("." components+=PathComponent)*
		public Group getGroup() { return cGroup; }
		
		//components+=PathComponent
		public Assignment getComponentsAssignment_0() { return cComponentsAssignment_0; }
		
		//PathComponent
		public RuleCall getComponentsPathComponentParserRuleCall_0_0() { return cComponentsPathComponentParserRuleCall_0_0; }
		
		//("." components+=PathComponent)*
		public Group getGroup_1() { return cGroup_1; }
		
		//"."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }
		
		//components+=PathComponent
		public Assignment getComponentsAssignment_1_1() { return cComponentsAssignment_1_1; }
		
		//PathComponent
		public RuleCall getComponentsPathComponentParserRuleCall_1_1_0() { return cComponentsPathComponentParserRuleCall_1_1_0; }
	}
	public class PathComponentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.PathComponent");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInverseAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cInverseTildeKeyword_0_0 = (Keyword)cInverseAssignment_0.eContents().get(0);
		private final Assignment cSymbolAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cSymbolSymbolCrossReference_1_0 = (CrossReference)cSymbolAssignment_1.eContents().get(0);
		private final RuleCall cSymbolSymbolQualifiedNameParserRuleCall_1_0_1 = (RuleCall)cSymbolSymbolCrossReference_1_0.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cTransitiveClosureAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cTransitiveClosureTRANSITIVE_CLOSURETerminalRuleCall_2_0_0 = (RuleCall)cTransitiveClosureAssignment_2_0.eContents().get(0);
		private final Assignment cReflexiveTransitiveClosureAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cReflexiveTransitiveClosureREFLEXIVE_TRANSITIVE_CLOSURETerminalRuleCall_2_1_0 = (RuleCall)cReflexiveTransitiveClosureAssignment_2_1.eContents().get(0);
		
		//PathComponent:
		//	inverse?="~"? symbol=[Symbol|QualifiedName] (transitiveClosure?=TRANSITIVE_CLOSURE |
		//	reflexiveTransitiveClosure?=REFLEXIVE_TRANSITIVE_CLOSURE)?;
		@Override public ParserRule getRule() { return rule; }
		
		//inverse?="~"? symbol=[Symbol|QualifiedName] (transitiveClosure?=TRANSITIVE_CLOSURE |
		//reflexiveTransitiveClosure?=REFLEXIVE_TRANSITIVE_CLOSURE)?
		public Group getGroup() { return cGroup; }
		
		//inverse?="~"?
		public Assignment getInverseAssignment_0() { return cInverseAssignment_0; }
		
		//"~"
		public Keyword getInverseTildeKeyword_0_0() { return cInverseTildeKeyword_0_0; }
		
		//symbol=[Symbol|QualifiedName]
		public Assignment getSymbolAssignment_1() { return cSymbolAssignment_1; }
		
		//[Symbol|QualifiedName]
		public CrossReference getSymbolSymbolCrossReference_1_0() { return cSymbolSymbolCrossReference_1_0; }
		
		//QualifiedName
		public RuleCall getSymbolSymbolQualifiedNameParserRuleCall_1_0_1() { return cSymbolSymbolQualifiedNameParserRuleCall_1_0_1; }
		
		//(transitiveClosure?=TRANSITIVE_CLOSURE | reflexiveTransitiveClosure?=REFLEXIVE_TRANSITIVE_CLOSURE)?
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//transitiveClosure?=TRANSITIVE_CLOSURE
		public Assignment getTransitiveClosureAssignment_2_0() { return cTransitiveClosureAssignment_2_0; }
		
		//TRANSITIVE_CLOSURE
		public RuleCall getTransitiveClosureTRANSITIVE_CLOSURETerminalRuleCall_2_0_0() { return cTransitiveClosureTRANSITIVE_CLOSURETerminalRuleCall_2_0_0; }
		
		//reflexiveTransitiveClosure?=REFLEXIVE_TRANSITIVE_CLOSURE
		public Assignment getReflexiveTransitiveClosureAssignment_2_1() { return cReflexiveTransitiveClosureAssignment_2_1; }
		
		//REFLEXIVE_TRANSITIVE_CLOSURE
		public RuleCall getReflexiveTransitiveClosureREFLEXIVE_TRANSITIVE_CLOSURETerminalRuleCall_2_1_0() { return cReflexiveTransitiveClosureREFLEXIVE_TRANSITIVE_CLOSURETerminalRuleCall_2_1_0; }
	}
	public class IntervalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Interval");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLowerBoundAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLowerBoundAdditiveExpressionParserRuleCall_1_0 = (RuleCall)cLowerBoundAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cUpperBoundAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cUpperBoundAdditiveExpressionParserRuleCall_3_0 = (RuleCall)cUpperBoundAssignment_3.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Interval:
		//	"[" lowerBound=AdditiveExpression "," upperBound=AdditiveExpression "]";
		@Override public ParserRule getRule() { return rule; }
		
		//"[" lowerBound=AdditiveExpression "," upperBound=AdditiveExpression "]"
		public Group getGroup() { return cGroup; }
		
		//"["
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//lowerBound=AdditiveExpression
		public Assignment getLowerBoundAssignment_1() { return cLowerBoundAssignment_1; }
		
		//AdditiveExpression
		public RuleCall getLowerBoundAdditiveExpressionParserRuleCall_1_0() { return cLowerBoundAdditiveExpressionParserRuleCall_1_0; }
		
		//","
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }
		
		//upperBound=AdditiveExpression
		public Assignment getUpperBoundAssignment_3() { return cUpperBoundAssignment_3; }
		
		//AdditiveExpression
		public RuleCall getUpperBoundAdditiveExpressionParserRuleCall_3_0() { return cUpperBoundAdditiveExpressionParserRuleCall_3_0; }
		
		//"]"
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }
	}
	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLogicLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIntLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cRealLiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cInfinityLiteralParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cEmptyLiteralParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cStringLiteralParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//Literal:
		//	LogicLiteral | IntLiteral | RealLiteral | InfinityLiteral | EmptyLiteral | StringLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//LogicLiteral | IntLiteral | RealLiteral | InfinityLiteral | EmptyLiteral | StringLiteral
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//LogicLiteral
		public RuleCall getLogicLiteralParserRuleCall_0() { return cLogicLiteralParserRuleCall_0; }
		
		//IntLiteral
		public RuleCall getIntLiteralParserRuleCall_1() { return cIntLiteralParserRuleCall_1; }
		
		//RealLiteral
		public RuleCall getRealLiteralParserRuleCall_2() { return cRealLiteralParserRuleCall_2; }
		
		//InfinityLiteral
		public RuleCall getInfinityLiteralParserRuleCall_3() { return cInfinityLiteralParserRuleCall_3; }
		
		//EmptyLiteral
		public RuleCall getEmptyLiteralParserRuleCall_4() { return cEmptyLiteralParserRuleCall_4; }
		
		//StringLiteral
		public RuleCall getStringLiteralParserRuleCall_5() { return cStringLiteralParserRuleCall_5; }
	}
	public class LogicLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.LogicLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueLogicValueEnumRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//LogicLiteral:
		//	value=LogicValue;
		@Override public ParserRule getRule() { return rule; }
		
		//value=LogicValue
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//LogicValue
		public RuleCall getValueLogicValueEnumRuleCall_0() { return cValueLogicValueEnumRuleCall_0; }
	}
	public class IntLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.IntLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//IntLiteral:
		//	value=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//value=INT
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//INT
		public RuleCall getValueINTTerminalRuleCall_0() { return cValueINTTerminalRuleCall_0; }
	}
	public class RealLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.RealLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueRealParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//RealLiteral:
		//	value=Real;
		@Override public ParserRule getRule() { return rule; }
		
		//value=Real
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//Real
		public RuleCall getValueRealParserRuleCall_0() { return cValueRealParserRuleCall_0; }
	}
	public class InfinityLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.InfinityLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cInfinityLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cInfKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//InfinityLiteral:
		//	{InfinityLiteral} "inf";
		@Override public ParserRule getRule() { return rule; }
		
		//{InfinityLiteral} "inf"
		public Group getGroup() { return cGroup; }
		
		//{InfinityLiteral}
		public Action getInfinityLiteralAction_0() { return cInfinityLiteralAction_0; }
		
		//"inf"
		public Keyword getInfKeyword_1() { return cInfKeyword_1; }
	}
	public class EmptyLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.EmptyLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cEmptyLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cEmptyKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//EmptyLiteral:
		//	{EmptyLiteral} "empty";
		@Override public ParserRule getRule() { return rule; }
		
		//{EmptyLiteral} "empty"
		public Group getGroup() { return cGroup; }
		
		//{EmptyLiteral}
		public Action getEmptyLiteralAction_0() { return cEmptyLiteralAction_0; }
		
		//"empty"
		public Keyword getEmptyKeyword_1() { return cEmptyKeyword_1; }
	}
	public class StringLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.StringLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//StringLiteral:
		//	value=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//value=STRING
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_0() { return cValueSTRINGTerminalRuleCall_0; }
	}
	public class ClassDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ClassDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final UnorderedGroup cUnorderedGroup_0 = (UnorderedGroup)cGroup.eContents().get(0);
		private final Assignment cAbstractAssignment_0_0 = (Assignment)cUnorderedGroup_0.eContents().get(0);
		private final Keyword cAbstractAbstractKeyword_0_0_0 = (Keyword)cAbstractAssignment_0_0.eContents().get(0);
		private final Assignment cRootAssignment_0_1 = (Assignment)cUnorderedGroup_0.eContents().get(1);
		private final Keyword cRootRootKeyword_0_1_0 = (Keyword)cRootAssignment_0_1.eContents().get(0);
		private final Keyword cClassKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cExtendsKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cSupertypesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final CrossReference cSupertypesSymbolCrossReference_3_1_0 = (CrossReference)cSupertypesAssignment_3_1.eContents().get(0);
		private final RuleCall cSupertypesSymbolQualifiedNameParserRuleCall_3_1_0_1 = (RuleCall)cSupertypesSymbolCrossReference_3_1_0.eContents().get(1);
		private final Group cGroup_3_2 = (Group)cGroup_3.eContents().get(2);
		private final Keyword cCommaKeyword_3_2_0 = (Keyword)cGroup_3_2.eContents().get(0);
		private final Assignment cSupertypesAssignment_3_2_1 = (Assignment)cGroup_3_2.eContents().get(1);
		private final CrossReference cSupertypesSymbolCrossReference_3_2_1_0 = (CrossReference)cSupertypesAssignment_3_2_1.eContents().get(0);
		private final RuleCall cSupertypesSymbolQualifiedNameParserRuleCall_3_2_1_0_1 = (RuleCall)cSupertypesSymbolCrossReference_3_2_1_0.eContents().get(1);
		private final Alternatives cAlternatives_4 = (Alternatives)cGroup.eContents().get(4);
		private final Group cGroup_4_0 = (Group)cAlternatives_4.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_4_0_0 = (Keyword)cGroup_4_0.eContents().get(0);
		private final Assignment cFieldsAssignment_4_0_1 = (Assignment)cGroup_4_0.eContents().get(1);
		private final RuleCall cFieldsFieldParserRuleCall_4_0_1_0 = (RuleCall)cFieldsAssignment_4_0_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4_0_2 = (Keyword)cGroup_4_0.eContents().get(2);
		private final RuleCall cFULL_STOPTerminalRuleCall_4_1 = (RuleCall)cAlternatives_4.eContents().get(1);
		
		//ClassDeclaration:
		//	(abstract?="abstract"? & root?="root"?) "class" name=ID ("extends" supertypes+=[Symbol|QualifiedName] (","
		//	supertypes+=[Symbol|QualifiedName])*)? ("{" fields+=Field* "}" | FULL_STOP);
		@Override public ParserRule getRule() { return rule; }
		
		//(abstract?="abstract"? & root?="root"?) "class" name=ID ("extends" supertypes+=[Symbol|QualifiedName] (","
		//supertypes+=[Symbol|QualifiedName])*)? ("{" fields+=Field* "}" | FULL_STOP)
		public Group getGroup() { return cGroup; }
		
		//abstract?="abstract"? & root?="root"?
		public UnorderedGroup getUnorderedGroup_0() { return cUnorderedGroup_0; }
		
		//abstract?="abstract"?
		public Assignment getAbstractAssignment_0_0() { return cAbstractAssignment_0_0; }
		
		//"abstract"
		public Keyword getAbstractAbstractKeyword_0_0_0() { return cAbstractAbstractKeyword_0_0_0; }
		
		//root?="root"?
		public Assignment getRootAssignment_0_1() { return cRootAssignment_0_1; }
		
		//"root"
		public Keyword getRootRootKeyword_0_1_0() { return cRootRootKeyword_0_1_0; }
		
		//"class"
		public Keyword getClassKeyword_1() { return cClassKeyword_1; }
		
		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }
		
		//("extends" supertypes+=[Symbol|QualifiedName] ("," supertypes+=[Symbol|QualifiedName])*)?
		public Group getGroup_3() { return cGroup_3; }
		
		//"extends"
		public Keyword getExtendsKeyword_3_0() { return cExtendsKeyword_3_0; }
		
		//supertypes+=[Symbol|QualifiedName]
		public Assignment getSupertypesAssignment_3_1() { return cSupertypesAssignment_3_1; }
		
		//[Symbol|QualifiedName]
		public CrossReference getSupertypesSymbolCrossReference_3_1_0() { return cSupertypesSymbolCrossReference_3_1_0; }
		
		//QualifiedName
		public RuleCall getSupertypesSymbolQualifiedNameParserRuleCall_3_1_0_1() { return cSupertypesSymbolQualifiedNameParserRuleCall_3_1_0_1; }
		
		//("," supertypes+=[Symbol|QualifiedName])*
		public Group getGroup_3_2() { return cGroup_3_2; }
		
		//","
		public Keyword getCommaKeyword_3_2_0() { return cCommaKeyword_3_2_0; }
		
		//supertypes+=[Symbol|QualifiedName]
		public Assignment getSupertypesAssignment_3_2_1() { return cSupertypesAssignment_3_2_1; }
		
		//[Symbol|QualifiedName]
		public CrossReference getSupertypesSymbolCrossReference_3_2_1_0() { return cSupertypesSymbolCrossReference_3_2_1_0; }
		
		//QualifiedName
		public RuleCall getSupertypesSymbolQualifiedNameParserRuleCall_3_2_1_0_1() { return cSupertypesSymbolQualifiedNameParserRuleCall_3_2_1_0_1; }
		
		//"{" fields+=Field* "}" | FULL_STOP
		public Alternatives getAlternatives_4() { return cAlternatives_4; }
		
		//"{" fields+=Field* "}"
		public Group getGroup_4_0() { return cGroup_4_0; }
		
		//"{"
		public Keyword getLeftCurlyBracketKeyword_4_0_0() { return cLeftCurlyBracketKeyword_4_0_0; }
		
		//fields+=Field*
		public Assignment getFieldsAssignment_4_0_1() { return cFieldsAssignment_4_0_1; }
		
		//Field
		public RuleCall getFieldsFieldParserRuleCall_4_0_1_0() { return cFieldsFieldParserRuleCall_4_0_1_0; }
		
		//"}"
		public Keyword getRightCurlyBracketKeyword_4_0_2() { return cRightCurlyBracketKeyword_4_0_2; }
		
		//FULL_STOP
		public RuleCall getFULL_STOPTerminalRuleCall_4_1() { return cFULL_STOPTerminalRuleCall_4_1; }
	}
	public class FieldElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Field");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cContainmentAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final Keyword cContainmentContainsKeyword_0_0_0 = (Keyword)cContainmentAssignment_0_0.eContents().get(0);
		private final Assignment cCrossReferenceAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final Keyword cCrossReferenceRefersKeyword_0_1_0 = (Keyword)cCrossReferenceAssignment_0_1.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cTypeSymbolCrossReference_1_0 = (CrossReference)cTypeAssignment_1.eContents().get(0);
		private final RuleCall cTypeSymbolQualifiedNameParserRuleCall_1_0_1 = (RuleCall)cTypeSymbolCrossReference_1_0.eContents().get(1);
		private final Assignment cMultiplicityAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cMultiplicityMultiplicityParserRuleCall_2_0 = (RuleCall)cMultiplicityAssignment_2.eContents().get(0);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameIDTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cOppositeKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cOppositeAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final CrossReference cOppositeSymbolCrossReference_4_1_0 = (CrossReference)cOppositeAssignment_4_1.eContents().get(0);
		private final RuleCall cOppositeSymbolQualifiedNameParserRuleCall_4_1_0_1 = (RuleCall)cOppositeSymbolCrossReference_4_1_0.eContents().get(1);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Field:
		//	(containment?="contains" | crossReference?="refers")? type=[Symbol|QualifiedName] multiplicity=Multiplicity?
		//	name=ID ("opposite" opposite=[Symbol|QualifiedName])? ";"?;
		@Override public ParserRule getRule() { return rule; }
		
		//(containment?="contains" | crossReference?="refers")? type=[Symbol|QualifiedName] multiplicity=Multiplicity? name=ID
		//("opposite" opposite=[Symbol|QualifiedName])? ";"?
		public Group getGroup() { return cGroup; }
		
		//(containment?="contains" | crossReference?="refers")?
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//containment?="contains"
		public Assignment getContainmentAssignment_0_0() { return cContainmentAssignment_0_0; }
		
		//"contains"
		public Keyword getContainmentContainsKeyword_0_0_0() { return cContainmentContainsKeyword_0_0_0; }
		
		//crossReference?="refers"
		public Assignment getCrossReferenceAssignment_0_1() { return cCrossReferenceAssignment_0_1; }
		
		//"refers"
		public Keyword getCrossReferenceRefersKeyword_0_1_0() { return cCrossReferenceRefersKeyword_0_1_0; }
		
		//type=[Symbol|QualifiedName]
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }
		
		//[Symbol|QualifiedName]
		public CrossReference getTypeSymbolCrossReference_1_0() { return cTypeSymbolCrossReference_1_0; }
		
		//QualifiedName
		public RuleCall getTypeSymbolQualifiedNameParserRuleCall_1_0_1() { return cTypeSymbolQualifiedNameParserRuleCall_1_0_1; }
		
		//multiplicity=Multiplicity?
		public Assignment getMultiplicityAssignment_2() { return cMultiplicityAssignment_2; }
		
		//Multiplicity
		public RuleCall getMultiplicityMultiplicityParserRuleCall_2_0() { return cMultiplicityMultiplicityParserRuleCall_2_0; }
		
		//name=ID
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_3_0() { return cNameIDTerminalRuleCall_3_0; }
		
		//("opposite" opposite=[Symbol|QualifiedName])?
		public Group getGroup_4() { return cGroup_4; }
		
		//"opposite"
		public Keyword getOppositeKeyword_4_0() { return cOppositeKeyword_4_0; }
		
		//opposite=[Symbol|QualifiedName]
		public Assignment getOppositeAssignment_4_1() { return cOppositeAssignment_4_1; }
		
		//[Symbol|QualifiedName]
		public CrossReference getOppositeSymbolCrossReference_4_1_0() { return cOppositeSymbolCrossReference_4_1_0; }
		
		//QualifiedName
		public RuleCall getOppositeSymbolQualifiedNameParserRuleCall_4_1_0_1() { return cOppositeSymbolQualifiedNameParserRuleCall_4_1_0_1; }
		
		//";"?
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}
	public class MultiplicityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Multiplicity");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUnboundedMultiplicityParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExactMultiplicityParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBoundedMultiplicityParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Multiplicity:
		//	UnboundedMultiplicity | ExactMultiplicity | BoundedMultiplicity;
		@Override public ParserRule getRule() { return rule; }
		
		//UnboundedMultiplicity | ExactMultiplicity | BoundedMultiplicity
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//UnboundedMultiplicity
		public RuleCall getUnboundedMultiplicityParserRuleCall_0() { return cUnboundedMultiplicityParserRuleCall_0; }
		
		//ExactMultiplicity
		public RuleCall getExactMultiplicityParserRuleCall_1() { return cExactMultiplicityParserRuleCall_1; }
		
		//BoundedMultiplicity
		public RuleCall getBoundedMultiplicityParserRuleCall_2() { return cBoundedMultiplicityParserRuleCall_2; }
	}
	public class UnboundedMultiplicityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.UnboundedMultiplicity");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cUnboundedMultiplicityAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cRightSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//UnboundedMultiplicity:
		//	{UnboundedMultiplicity} "[" "]";
		@Override public ParserRule getRule() { return rule; }
		
		//{UnboundedMultiplicity} "[" "]"
		public Group getGroup() { return cGroup; }
		
		//{UnboundedMultiplicity}
		public Action getUnboundedMultiplicityAction_0() { return cUnboundedMultiplicityAction_0; }
		
		//"["
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }
		
		//"]"
		public Keyword getRightSquareBracketKeyword_2() { return cRightSquareBracketKeyword_2; }
	}
	public class ExactMultiplicityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ExactMultiplicity");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueUpperMultiplictyParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//ExactMultiplicity:
		//	"[" value=UpperMultiplicty "]";
		@Override public ParserRule getRule() { return rule; }
		
		//"[" value=UpperMultiplicty "]"
		public Group getGroup() { return cGroup; }
		
		//"["
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//value=UpperMultiplicty
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//UpperMultiplicty
		public RuleCall getValueUpperMultiplictyParserRuleCall_1_0() { return cValueUpperMultiplictyParserRuleCall_1_0; }
		
		//"]"
		public Keyword getRightSquareBracketKeyword_2() { return cRightSquareBracketKeyword_2; }
	}
	public class BoundedMultiplicityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.BoundedMultiplicity");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLowerBoundAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLowerBoundINTTerminalRuleCall_1_0 = (RuleCall)cLowerBoundAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cUpperBoundAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cUpperBoundUpperMultiplictyParserRuleCall_3_0 = (RuleCall)cUpperBoundAssignment_3.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//BoundedMultiplicity:
		//	"[" lowerBound=INT "," upperBound=UpperMultiplicty "]";
		@Override public ParserRule getRule() { return rule; }
		
		//"[" lowerBound=INT "," upperBound=UpperMultiplicty "]"
		public Group getGroup() { return cGroup; }
		
		//"["
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//lowerBound=INT
		public Assignment getLowerBoundAssignment_1() { return cLowerBoundAssignment_1; }
		
		//INT
		public RuleCall getLowerBoundINTTerminalRuleCall_1_0() { return cLowerBoundINTTerminalRuleCall_1_0; }
		
		//","
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }
		
		//upperBound=UpperMultiplicty
		public Assignment getUpperBoundAssignment_3() { return cUpperBoundAssignment_3; }
		
		//UpperMultiplicty
		public RuleCall getUpperBoundUpperMultiplictyParserRuleCall_3_0() { return cUpperBoundUpperMultiplictyParserRuleCall_3_0; }
		
		//"]"
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }
	}
	public class EnumDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.EnumDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEnumKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cAlternatives_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2_0_0 = (Keyword)cGroup_2_0.eContents().get(0);
		private final Group cGroup_2_0_1 = (Group)cGroup_2_0.eContents().get(1);
		private final Assignment cLiteralsAssignment_2_0_1_0 = (Assignment)cGroup_2_0_1.eContents().get(0);
		private final RuleCall cLiteralsEnumLiteralParserRuleCall_2_0_1_0_0 = (RuleCall)cLiteralsAssignment_2_0_1_0.eContents().get(0);
		private final Group cGroup_2_0_1_1 = (Group)cGroup_2_0_1.eContents().get(1);
		private final Keyword cCommaKeyword_2_0_1_1_0 = (Keyword)cGroup_2_0_1_1.eContents().get(0);
		private final Assignment cLiteralsAssignment_2_0_1_1_1 = (Assignment)cGroup_2_0_1_1.eContents().get(1);
		private final RuleCall cLiteralsEnumLiteralParserRuleCall_2_0_1_1_1_0 = (RuleCall)cLiteralsAssignment_2_0_1_1_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_2_0_2 = (Keyword)cGroup_2_0.eContents().get(2);
		private final RuleCall cFULL_STOPTerminalRuleCall_2_1 = (RuleCall)cAlternatives_2.eContents().get(1);
		
		//EnumDeclaration:
		//	"enum" name=ID ("{" (literals+=EnumLiteral (","? literals+=EnumLiteral)*)? "}" | FULL_STOP);
		@Override public ParserRule getRule() { return rule; }
		
		//"enum" name=ID ("{" (literals+=EnumLiteral (","? literals+=EnumLiteral)*)? "}" | FULL_STOP)
		public Group getGroup() { return cGroup; }
		
		//"enum"
		public Keyword getEnumKeyword_0() { return cEnumKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//"{" (literals+=EnumLiteral (","? literals+=EnumLiteral)*)? "}" | FULL_STOP
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//"{" (literals+=EnumLiteral (","? literals+=EnumLiteral)*)? "}"
		public Group getGroup_2_0() { return cGroup_2_0; }
		
		//"{"
		public Keyword getLeftCurlyBracketKeyword_2_0_0() { return cLeftCurlyBracketKeyword_2_0_0; }
		
		//(literals+=EnumLiteral (","? literals+=EnumLiteral)*)?
		public Group getGroup_2_0_1() { return cGroup_2_0_1; }
		
		//literals+=EnumLiteral
		public Assignment getLiteralsAssignment_2_0_1_0() { return cLiteralsAssignment_2_0_1_0; }
		
		//EnumLiteral
		public RuleCall getLiteralsEnumLiteralParserRuleCall_2_0_1_0_0() { return cLiteralsEnumLiteralParserRuleCall_2_0_1_0_0; }
		
		//(","? literals+=EnumLiteral)*
		public Group getGroup_2_0_1_1() { return cGroup_2_0_1_1; }
		
		//","?
		public Keyword getCommaKeyword_2_0_1_1_0() { return cCommaKeyword_2_0_1_1_0; }
		
		//literals+=EnumLiteral
		public Assignment getLiteralsAssignment_2_0_1_1_1() { return cLiteralsAssignment_2_0_1_1_1; }
		
		//EnumLiteral
		public RuleCall getLiteralsEnumLiteralParserRuleCall_2_0_1_1_1_0() { return cLiteralsEnumLiteralParserRuleCall_2_0_1_1_1_0; }
		
		//"}"
		public Keyword getRightCurlyBracketKeyword_2_0_2() { return cRightCurlyBracketKeyword_2_0_2; }
		
		//FULL_STOP
		public RuleCall getFULL_STOPTerminalRuleCall_2_1() { return cFULL_STOPTerminalRuleCall_2_1; }
	}
	public class EnumLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.EnumLiteral");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//EnumLiteral:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class ScopeDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ScopeDeclaration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cExactScopeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBoundedScopeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cLowerBoundedScopeParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//ScopeDeclaration:
		//	ExactScope | BoundedScope | LowerBoundedScope;
		@Override public ParserRule getRule() { return rule; }
		
		//ExactScope | BoundedScope | LowerBoundedScope
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ExactScope
		public RuleCall getExactScopeParserRuleCall_0() { return cExactScopeParserRuleCall_0; }
		
		//BoundedScope
		public RuleCall getBoundedScopeParserRuleCall_1() { return cBoundedScopeParserRuleCall_1; }
		
		//LowerBoundedScope
		public RuleCall getLowerBoundedScopeParserRuleCall_2() { return cLowerBoundedScopeParserRuleCall_2; }
	}
	public class ExactScopeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ExactScope");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cScopeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cTypeSymbolCrossReference_1_0 = (CrossReference)cTypeAssignment_1.eContents().get(0);
		private final RuleCall cTypeSymbolQualifiedNameParserRuleCall_1_0_1 = (RuleCall)cTypeSymbolCrossReference_1_0.eContents().get(1);
		private final Keyword cEqualsSignEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cSizeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cSizeINTTerminalRuleCall_3_0 = (RuleCall)cSizeAssignment_3.eContents().get(0);
		private final RuleCall cFULL_STOPTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//ExactScope:
		//	"scope" type=[Symbol|QualifiedName] "==" size=INT FULL_STOP;
		@Override public ParserRule getRule() { return rule; }
		
		//"scope" type=[Symbol|QualifiedName] "==" size=INT FULL_STOP
		public Group getGroup() { return cGroup; }
		
		//"scope"
		public Keyword getScopeKeyword_0() { return cScopeKeyword_0; }
		
		//type=[Symbol|QualifiedName]
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }
		
		//[Symbol|QualifiedName]
		public CrossReference getTypeSymbolCrossReference_1_0() { return cTypeSymbolCrossReference_1_0; }
		
		//QualifiedName
		public RuleCall getTypeSymbolQualifiedNameParserRuleCall_1_0_1() { return cTypeSymbolQualifiedNameParserRuleCall_1_0_1; }
		
		//"=="
		public Keyword getEqualsSignEqualsSignKeyword_2() { return cEqualsSignEqualsSignKeyword_2; }
		
		//size=INT
		public Assignment getSizeAssignment_3() { return cSizeAssignment_3; }
		
		//INT
		public RuleCall getSizeINTTerminalRuleCall_3_0() { return cSizeINTTerminalRuleCall_3_0; }
		
		//FULL_STOP
		public RuleCall getFULL_STOPTerminalRuleCall_4() { return cFULL_STOPTerminalRuleCall_4; }
	}
	public class BoundedScopeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.BoundedScope");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cScopeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Assignment cLowerBoundAssignment_1_0_0_0 = (Assignment)cGroup_1_0_0.eContents().get(0);
		private final RuleCall cLowerBoundINTTerminalRuleCall_1_0_0_0_0 = (RuleCall)cLowerBoundAssignment_1_0_0_0.eContents().get(0);
		private final Keyword cLessThanSignEqualsSignKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Assignment cTypeAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final CrossReference cTypeSymbolCrossReference_1_0_1_0 = (CrossReference)cTypeAssignment_1_0_1.eContents().get(0);
		private final RuleCall cTypeSymbolQualifiedNameParserRuleCall_1_0_1_0_1 = (RuleCall)cTypeSymbolCrossReference_1_0_1_0.eContents().get(1);
		private final Keyword cLessThanSignEqualsSignKeyword_1_0_2 = (Keyword)cGroup_1_0.eContents().get(2);
		private final Assignment cUpperBoundAssignment_1_0_3 = (Assignment)cGroup_1_0.eContents().get(3);
		private final RuleCall cUpperBoundINTTerminalRuleCall_1_0_3_0 = (RuleCall)cUpperBoundAssignment_1_0_3.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Assignment cUpperBoundAssignment_1_1_0 = (Assignment)cGroup_1_1.eContents().get(0);
		private final RuleCall cUpperBoundINTTerminalRuleCall_1_1_0_0 = (RuleCall)cUpperBoundAssignment_1_1_0.eContents().get(0);
		private final Keyword cGreaterThanSignEqualsSignKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		private final Assignment cTypeAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final CrossReference cTypeSymbolCrossReference_1_1_2_0 = (CrossReference)cTypeAssignment_1_1_2.eContents().get(0);
		private final RuleCall cTypeSymbolQualifiedNameParserRuleCall_1_1_2_0_1 = (RuleCall)cTypeSymbolCrossReference_1_1_2_0.eContents().get(1);
		private final Group cGroup_1_1_3 = (Group)cGroup_1_1.eContents().get(3);
		private final Keyword cGreaterThanSignEqualsSignKeyword_1_1_3_0 = (Keyword)cGroup_1_1_3.eContents().get(0);
		private final Assignment cLowerBoundAssignment_1_1_3_1 = (Assignment)cGroup_1_1_3.eContents().get(1);
		private final RuleCall cLowerBoundINTTerminalRuleCall_1_1_3_1_0 = (RuleCall)cLowerBoundAssignment_1_1_3_1.eContents().get(0);
		private final RuleCall cFULL_STOPTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//BoundedScope:
		//	"scope" ((lowerBound=INT "<=")? type=[Symbol|QualifiedName] "<=" upperBound=INT | upperBound=INT ">="
		//	type=[Symbol|QualifiedName] (">=" lowerBound=INT)?) FULL_STOP;
		@Override public ParserRule getRule() { return rule; }
		
		//"scope" ((lowerBound=INT "<=")? type=[Symbol|QualifiedName] "<=" upperBound=INT | upperBound=INT ">="
		//type=[Symbol|QualifiedName] (">=" lowerBound=INT)?) FULL_STOP
		public Group getGroup() { return cGroup; }
		
		//"scope"
		public Keyword getScopeKeyword_0() { return cScopeKeyword_0; }
		
		//(lowerBound=INT "<=")? type=[Symbol|QualifiedName] "<=" upperBound=INT | upperBound=INT ">=" type=[Symbol|QualifiedName]
		//(">=" lowerBound=INT)?
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//(lowerBound=INT "<=")? type=[Symbol|QualifiedName] "<=" upperBound=INT
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//(lowerBound=INT "<=")?
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//lowerBound=INT
		public Assignment getLowerBoundAssignment_1_0_0_0() { return cLowerBoundAssignment_1_0_0_0; }
		
		//INT
		public RuleCall getLowerBoundINTTerminalRuleCall_1_0_0_0_0() { return cLowerBoundINTTerminalRuleCall_1_0_0_0_0; }
		
		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_1_0_0_1() { return cLessThanSignEqualsSignKeyword_1_0_0_1; }
		
		//type=[Symbol|QualifiedName]
		public Assignment getTypeAssignment_1_0_1() { return cTypeAssignment_1_0_1; }
		
		//[Symbol|QualifiedName]
		public CrossReference getTypeSymbolCrossReference_1_0_1_0() { return cTypeSymbolCrossReference_1_0_1_0; }
		
		//QualifiedName
		public RuleCall getTypeSymbolQualifiedNameParserRuleCall_1_0_1_0_1() { return cTypeSymbolQualifiedNameParserRuleCall_1_0_1_0_1; }
		
		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_1_0_2() { return cLessThanSignEqualsSignKeyword_1_0_2; }
		
		//upperBound=INT
		public Assignment getUpperBoundAssignment_1_0_3() { return cUpperBoundAssignment_1_0_3; }
		
		//INT
		public RuleCall getUpperBoundINTTerminalRuleCall_1_0_3_0() { return cUpperBoundINTTerminalRuleCall_1_0_3_0; }
		
		//upperBound=INT ">=" type=[Symbol|QualifiedName] (">=" lowerBound=INT)?
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//upperBound=INT
		public Assignment getUpperBoundAssignment_1_1_0() { return cUpperBoundAssignment_1_1_0; }
		
		//INT
		public RuleCall getUpperBoundINTTerminalRuleCall_1_1_0_0() { return cUpperBoundINTTerminalRuleCall_1_1_0_0; }
		
		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_1_1_1() { return cGreaterThanSignEqualsSignKeyword_1_1_1; }
		
		//type=[Symbol|QualifiedName]
		public Assignment getTypeAssignment_1_1_2() { return cTypeAssignment_1_1_2; }
		
		//[Symbol|QualifiedName]
		public CrossReference getTypeSymbolCrossReference_1_1_2_0() { return cTypeSymbolCrossReference_1_1_2_0; }
		
		//QualifiedName
		public RuleCall getTypeSymbolQualifiedNameParserRuleCall_1_1_2_0_1() { return cTypeSymbolQualifiedNameParserRuleCall_1_1_2_0_1; }
		
		//(">=" lowerBound=INT)?
		public Group getGroup_1_1_3() { return cGroup_1_1_3; }
		
		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_1_1_3_0() { return cGreaterThanSignEqualsSignKeyword_1_1_3_0; }
		
		//lowerBound=INT
		public Assignment getLowerBoundAssignment_1_1_3_1() { return cLowerBoundAssignment_1_1_3_1; }
		
		//INT
		public RuleCall getLowerBoundINTTerminalRuleCall_1_1_3_1_0() { return cLowerBoundINTTerminalRuleCall_1_1_3_1_0; }
		
		//FULL_STOP
		public RuleCall getFULL_STOPTerminalRuleCall_2() { return cFULL_STOPTerminalRuleCall_2; }
	}
	public class LowerBoundedScopeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.LowerBoundedScope");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cScopeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Assignment cLowerBoundAssignment_1_0_0 = (Assignment)cGroup_1_0.eContents().get(0);
		private final RuleCall cLowerBoundINTTerminalRuleCall_1_0_0_0 = (RuleCall)cLowerBoundAssignment_1_0_0.eContents().get(0);
		private final Keyword cLessThanSignEqualsSignKeyword_1_0_1 = (Keyword)cGroup_1_0.eContents().get(1);
		private final Assignment cTypeAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final CrossReference cTypeSymbolCrossReference_1_0_2_0 = (CrossReference)cTypeAssignment_1_0_2.eContents().get(0);
		private final RuleCall cTypeSymbolQualifiedNameParserRuleCall_1_0_2_0_1 = (RuleCall)cTypeSymbolCrossReference_1_0_2_0.eContents().get(1);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Assignment cTypeAssignment_1_1_0 = (Assignment)cGroup_1_1.eContents().get(0);
		private final CrossReference cTypeSymbolCrossReference_1_1_0_0 = (CrossReference)cTypeAssignment_1_1_0.eContents().get(0);
		private final RuleCall cTypeSymbolQualifiedNameParserRuleCall_1_1_0_0_1 = (RuleCall)cTypeSymbolCrossReference_1_1_0_0.eContents().get(1);
		private final Keyword cGreaterThanSignEqualsSignKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		private final Assignment cLowerBoundAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cLowerBoundINTTerminalRuleCall_1_1_2_0 = (RuleCall)cLowerBoundAssignment_1_1_2.eContents().get(0);
		private final RuleCall cFULL_STOPTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//LowerBoundedScope:
		//	"scope" (lowerBound=INT "<=" type=[Symbol|QualifiedName] | type=[Symbol|QualifiedName] ">=" lowerBound=INT)
		//	FULL_STOP;
		@Override public ParserRule getRule() { return rule; }
		
		//"scope" (lowerBound=INT "<=" type=[Symbol|QualifiedName] | type=[Symbol|QualifiedName] ">=" lowerBound=INT) FULL_STOP
		public Group getGroup() { return cGroup; }
		
		//"scope"
		public Keyword getScopeKeyword_0() { return cScopeKeyword_0; }
		
		//lowerBound=INT "<=" type=[Symbol|QualifiedName] | type=[Symbol|QualifiedName] ">=" lowerBound=INT
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//lowerBound=INT "<=" type=[Symbol|QualifiedName]
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//lowerBound=INT
		public Assignment getLowerBoundAssignment_1_0_0() { return cLowerBoundAssignment_1_0_0; }
		
		//INT
		public RuleCall getLowerBoundINTTerminalRuleCall_1_0_0_0() { return cLowerBoundINTTerminalRuleCall_1_0_0_0; }
		
		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_1_0_1() { return cLessThanSignEqualsSignKeyword_1_0_1; }
		
		//type=[Symbol|QualifiedName]
		public Assignment getTypeAssignment_1_0_2() { return cTypeAssignment_1_0_2; }
		
		//[Symbol|QualifiedName]
		public CrossReference getTypeSymbolCrossReference_1_0_2_0() { return cTypeSymbolCrossReference_1_0_2_0; }
		
		//QualifiedName
		public RuleCall getTypeSymbolQualifiedNameParserRuleCall_1_0_2_0_1() { return cTypeSymbolQualifiedNameParserRuleCall_1_0_2_0_1; }
		
		//type=[Symbol|QualifiedName] ">=" lowerBound=INT
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//type=[Symbol|QualifiedName]
		public Assignment getTypeAssignment_1_1_0() { return cTypeAssignment_1_1_0; }
		
		//[Symbol|QualifiedName]
		public CrossReference getTypeSymbolCrossReference_1_1_0_0() { return cTypeSymbolCrossReference_1_1_0_0; }
		
		//QualifiedName
		public RuleCall getTypeSymbolQualifiedNameParserRuleCall_1_1_0_0_1() { return cTypeSymbolQualifiedNameParserRuleCall_1_1_0_0_1; }
		
		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_1_1_1() { return cGreaterThanSignEqualsSignKeyword_1_1_1; }
		
		//lowerBound=INT
		public Assignment getLowerBoundAssignment_1_1_2() { return cLowerBoundAssignment_1_1_2; }
		
		//INT
		public RuleCall getLowerBoundINTTerminalRuleCall_1_1_2_0() { return cLowerBoundINTTerminalRuleCall_1_1_2_0; }
		
		//FULL_STOP
		public RuleCall getFULL_STOPTerminalRuleCall_2() { return cFULL_STOPTerminalRuleCall_2; }
	}
	public class ObjectiveDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ObjectiveDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cKindAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cKindObjectiveKindEnumRuleCall_0_0 = (RuleCall)cKindAssignment_0.eContents().get(0);
		private final Assignment cObjectiveAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cObjectiveExpressionParserRuleCall_1_0 = (RuleCall)cObjectiveAssignment_1.eContents().get(0);
		private final RuleCall cFULL_STOPTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//ObjectiveDeclaration:
		//	kind=ObjectiveKind objective=Expression FULL_STOP;
		@Override public ParserRule getRule() { return rule; }
		
		//kind=ObjectiveKind objective=Expression FULL_STOP
		public Group getGroup() { return cGroup; }
		
		//kind=ObjectiveKind
		public Assignment getKindAssignment_0() { return cKindAssignment_0; }
		
		//ObjectiveKind
		public RuleCall getKindObjectiveKindEnumRuleCall_0_0() { return cKindObjectiveKindEnumRuleCall_0_0; }
		
		//objective=Expression
		public Assignment getObjectiveAssignment_1() { return cObjectiveAssignment_1; }
		
		//Expression
		public RuleCall getObjectiveExpressionParserRuleCall_1_0() { return cObjectiveExpressionParserRuleCall_1_0; }
		
		//FULL_STOP
		public RuleCall getFULL_STOPTerminalRuleCall_2() { return cFULL_STOPTerminalRuleCall_2; }
	}
	public class UpperMultiplictyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.UpperMultiplicty");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Keyword cAsteriskKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//UpperMultiplicty ecore::EInt:
		//	INT | "*";
		@Override public ParserRule getRule() { return rule; }
		
		//INT | "*"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }
		
		//"*"
		public Keyword getAsteriskKeyword_1() { return cAsteriskKeyword_1; }
	}
	public class RealElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Real");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//Real ecore::EBigDecimal hidden():
		//	INT "." INT;
		@Override public ParserRule getRule() { return rule; }
		
		//INT "." INT
		public Group getGroup() { return cGroup; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }
		
		//"."
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_2() { return cINTTerminalRuleCall_2; }
	}
	public class QualifiedNameSegmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.QualifiedNameSegment");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cQUOTED_IDTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Keyword cObjectKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//QualifiedNameSegment:
		//	ID | QUOTED_ID | "object";
		@Override public ParserRule getRule() { return rule; }
		
		//ID | QUOTED_ID | "object"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }
		
		//QUOTED_ID
		public RuleCall getQUOTED_IDTerminalRuleCall_1() { return cQUOTED_IDTerminalRuleCall_1; }
		
		//"object"
		public Keyword getObjectKeyword_2() { return cObjectKeyword_2; }
	}
	public class QualifiedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.QualifiedName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cQualifiedNameSegmentParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cColonColonKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cQualifiedNameSegmentParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//QualifiedName hidden():
		//	QualifiedNameSegment ("::" QualifiedNameSegment)*;
		@Override public ParserRule getRule() { return rule; }
		
		//QualifiedNameSegment ("::" QualifiedNameSegment)*
		public Group getGroup() { return cGroup; }
		
		//QualifiedNameSegment
		public RuleCall getQualifiedNameSegmentParserRuleCall_0() { return cQualifiedNameSegmentParserRuleCall_0; }
		
		//("::" QualifiedNameSegment)*
		public Group getGroup_1() { return cGroup_1; }
		
		//"::"
		public Keyword getColonColonKeyword_1_0() { return cColonColonKeyword_1_0; }
		
		//QualifiedNameSegment
		public RuleCall getQualifiedNameSegmentParserRuleCall_1_1() { return cQualifiedNameSegmentParserRuleCall_1_1; }
	}
	
	public class AttributeKindElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.AttributeKind");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cFUNCTIONALEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cFUNCTIONALFunctionalKeyword_0_0 = (Keyword)cFUNCTIONALEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cERROREnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cERRORErrorKeyword_1_0 = (Keyword)cERROREnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cROOTEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cROOTRootKeyword_2_0 = (Keyword)cROOTEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cCONTAINMENTEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cCONTAINMENTContainmentKeyword_3_0 = (Keyword)cCONTAINMENTEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum AttributeKind:
		//	FUNCTIONAL="functional" | ERROR="error" | ROOT="root" | CONTAINMENT="containment";
		public EnumRule getRule() { return rule; }
		
		//FUNCTIONAL="functional" | ERROR="error" | ROOT="root" | CONTAINMENT="containment"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//FUNCTIONAL="functional"
		public EnumLiteralDeclaration getFUNCTIONALEnumLiteralDeclaration_0() { return cFUNCTIONALEnumLiteralDeclaration_0; }
		
		//"functional"
		public Keyword getFUNCTIONALFunctionalKeyword_0_0() { return cFUNCTIONALFunctionalKeyword_0_0; }
		
		//ERROR="error"
		public EnumLiteralDeclaration getERROREnumLiteralDeclaration_1() { return cERROREnumLiteralDeclaration_1; }
		
		//"error"
		public Keyword getERRORErrorKeyword_1_0() { return cERRORErrorKeyword_1_0; }
		
		//ROOT="root"
		public EnumLiteralDeclaration getROOTEnumLiteralDeclaration_2() { return cROOTEnumLiteralDeclaration_2; }
		
		//"root"
		public Keyword getROOTRootKeyword_2_0() { return cROOTRootKeyword_2_0; }
		
		//CONTAINMENT="containment"
		public EnumLiteralDeclaration getCONTAINMENTEnumLiteralDeclaration_3() { return cCONTAINMENTEnumLiteralDeclaration_3; }
		
		//"containment"
		public Keyword getCONTAINMENTContainmentKeyword_3_0() { return cCONTAINMENTContainmentKeyword_3_0; }
	}
	public class ComparisonOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ComparisonOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEQUALSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEQUALSEqualsSignEqualsSignKeyword_0_0 = (Keyword)cEQUALSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cNOT_EQUALSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cNOT_EQUALSExclamationMarkEqualsSignKeyword_1_0 = (Keyword)cNOT_EQUALSEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cLESSEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cLESSLessThanSignKeyword_2_0 = (Keyword)cLESSEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cLESS_EQUALSEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cLESS_EQUALSLessThanSignEqualsSignKeyword_3_0 = (Keyword)cLESS_EQUALSEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cGREATEREnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cGREATERGreaterThanSignKeyword_4_0 = (Keyword)cGREATEREnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cGREATER_EQUALSEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cGREATER_EQUALSGreaterThanSignEqualsSignKeyword_5_0 = (Keyword)cGREATER_EQUALSEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cINEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cINInKeyword_6_0 = (Keyword)cINEnumLiteralDeclaration_6.eContents().get(0);
		
		//enum ComparisonOperator returns BinaryOperator:
		//	EQUALS="==" | NOT_EQUALS="!=" | LESS="<" | LESS_EQUALS="<=" | GREATER=">" | GREATER_EQUALS=">=" | IN="in";
		public EnumRule getRule() { return rule; }
		
		//EQUALS="==" | NOT_EQUALS="!=" | LESS="<" | LESS_EQUALS="<=" | GREATER=">" | GREATER_EQUALS=">=" | IN="in"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//EQUALS="=="
		public EnumLiteralDeclaration getEQUALSEnumLiteralDeclaration_0() { return cEQUALSEnumLiteralDeclaration_0; }
		
		//"=="
		public Keyword getEQUALSEqualsSignEqualsSignKeyword_0_0() { return cEQUALSEqualsSignEqualsSignKeyword_0_0; }
		
		//NOT_EQUALS="!="
		public EnumLiteralDeclaration getNOT_EQUALSEnumLiteralDeclaration_1() { return cNOT_EQUALSEnumLiteralDeclaration_1; }
		
		//"!="
		public Keyword getNOT_EQUALSExclamationMarkEqualsSignKeyword_1_0() { return cNOT_EQUALSExclamationMarkEqualsSignKeyword_1_0; }
		
		//LESS="<"
		public EnumLiteralDeclaration getLESSEnumLiteralDeclaration_2() { return cLESSEnumLiteralDeclaration_2; }
		
		//"<"
		public Keyword getLESSLessThanSignKeyword_2_0() { return cLESSLessThanSignKeyword_2_0; }
		
		//LESS_EQUALS="<="
		public EnumLiteralDeclaration getLESS_EQUALSEnumLiteralDeclaration_3() { return cLESS_EQUALSEnumLiteralDeclaration_3; }
		
		//"<="
		public Keyword getLESS_EQUALSLessThanSignEqualsSignKeyword_3_0() { return cLESS_EQUALSLessThanSignEqualsSignKeyword_3_0; }
		
		//GREATER=">"
		public EnumLiteralDeclaration getGREATEREnumLiteralDeclaration_4() { return cGREATEREnumLiteralDeclaration_4; }
		
		//">"
		public Keyword getGREATERGreaterThanSignKeyword_4_0() { return cGREATERGreaterThanSignKeyword_4_0; }
		
		//GREATER_EQUALS=">="
		public EnumLiteralDeclaration getGREATER_EQUALSEnumLiteralDeclaration_5() { return cGREATER_EQUALSEnumLiteralDeclaration_5; }
		
		//">="
		public Keyword getGREATER_EQUALSGreaterThanSignEqualsSignKeyword_5_0() { return cGREATER_EQUALSGreaterThanSignEqualsSignKeyword_5_0; }
		
		//IN="in"
		public EnumLiteralDeclaration getINEnumLiteralDeclaration_6() { return cINEnumLiteralDeclaration_6; }
		
		//"in"
		public Keyword getINInKeyword_6_0() { return cINInKeyword_6_0; }
	}
	public class AdditiveBinaryOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.AdditiveBinaryOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPLUSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPLUSPlusSignKeyword_0_0 = (Keyword)cPLUSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMINUSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMINUSHyphenMinusKeyword_1_0 = (Keyword)cMINUSEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum AdditiveBinaryOperator returns BinaryOperator:
		//	PLUS="+" | MINUS="-";
		public EnumRule getRule() { return rule; }
		
		//PLUS="+" | MINUS="-"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PLUS="+"
		public EnumLiteralDeclaration getPLUSEnumLiteralDeclaration_0() { return cPLUSEnumLiteralDeclaration_0; }
		
		//"+"
		public Keyword getPLUSPlusSignKeyword_0_0() { return cPLUSPlusSignKeyword_0_0; }
		
		//MINUS="-"
		public EnumLiteralDeclaration getMINUSEnumLiteralDeclaration_1() { return cMINUSEnumLiteralDeclaration_1; }
		
		//"-"
		public Keyword getMINUSHyphenMinusKeyword_1_0() { return cMINUSHyphenMinusKeyword_1_0; }
	}
	public class MultiplicativeBinaryOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.MultiplicativeBinaryOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cMULTIPLYEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cMULTIPLYAsteriskKeyword_0_0 = (Keyword)cMULTIPLYEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDIVIDEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDIVIDESolidusKeyword_1_0 = (Keyword)cDIVIDEEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum MultiplicativeBinaryOperator returns BinaryOperator:
		//	MULTIPLY="*" | DIVIDE="/";
		public EnumRule getRule() { return rule; }
		
		//MULTIPLY="*" | DIVIDE="/"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//MULTIPLY="*"
		public EnumLiteralDeclaration getMULTIPLYEnumLiteralDeclaration_0() { return cMULTIPLYEnumLiteralDeclaration_0; }
		
		//"*"
		public Keyword getMULTIPLYAsteriskKeyword_0_0() { return cMULTIPLYAsteriskKeyword_0_0; }
		
		//DIVIDE="/"
		public EnumLiteralDeclaration getDIVIDEEnumLiteralDeclaration_1() { return cDIVIDEEnumLiteralDeclaration_1; }
		
		//"/"
		public Keyword getDIVIDESolidusKeyword_1_0() { return cDIVIDESolidusKeyword_1_0; }
	}
	public class ExponentialOpElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ExponentialOp");
		private final EnumLiteralDeclaration cPOWEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cPOWCircumflexAccentKeyword_0 = (Keyword)cPOWEnumLiteralDeclaration.eContents().get(0);
		
		//enum ExponentialOp returns BinaryOperator:
		//	POW="^";
		public EnumRule getRule() { return rule; }
		
		//POW="^"
		public EnumLiteralDeclaration getPOWEnumLiteralDeclaration() { return cPOWEnumLiteralDeclaration; }
		
		//"^"
		public Keyword getPOWCircumflexAccentKeyword_0() { return cPOWCircumflexAccentKeyword_0; }
	}
	public class UnaryOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.UnaryOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cNOTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cNOTExclamationMarkKeyword_0_0 = (Keyword)cNOTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cPLUSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cPLUSPlusSignKeyword_1_0 = (Keyword)cPLUSEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cMINUSEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cMINUSHyphenMinusKeyword_2_0 = (Keyword)cMINUSEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cMAYBEEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cMAYBEQuestionMarkKeyword_3_0 = (Keyword)cMAYBEEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum UnaryOperator:
		//	NOT="!" | PLUS="+" | MINUS="-" | MAYBE="?";
		public EnumRule getRule() { return rule; }
		
		//NOT="!" | PLUS="+" | MINUS="-" | MAYBE="?"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//NOT="!"
		public EnumLiteralDeclaration getNOTEnumLiteralDeclaration_0() { return cNOTEnumLiteralDeclaration_0; }
		
		//"!"
		public Keyword getNOTExclamationMarkKeyword_0_0() { return cNOTExclamationMarkKeyword_0_0; }
		
		//PLUS="+"
		public EnumLiteralDeclaration getPLUSEnumLiteralDeclaration_1() { return cPLUSEnumLiteralDeclaration_1; }
		
		//"+"
		public Keyword getPLUSPlusSignKeyword_1_0() { return cPLUSPlusSignKeyword_1_0; }
		
		//MINUS="-"
		public EnumLiteralDeclaration getMINUSEnumLiteralDeclaration_2() { return cMINUSEnumLiteralDeclaration_2; }
		
		//"-"
		public Keyword getMINUSHyphenMinusKeyword_2_0() { return cMINUSHyphenMinusKeyword_2_0; }
		
		//MAYBE="?"
		public EnumLiteralDeclaration getMAYBEEnumLiteralDeclaration_3() { return cMAYBEEnumLiteralDeclaration_3; }
		
		//"?"
		public Keyword getMAYBEQuestionMarkKeyword_3_0() { return cMAYBEQuestionMarkKeyword_3_0; }
	}
	public class LogicValueElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.LogicValue");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cTRUEEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cTRUETrueKeyword_0_0 = (Keyword)cTRUEEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cFALSEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cFALSEFalseKeyword_1_0 = (Keyword)cFALSEEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cUNKNOWNEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cUNKNOWNUnknownKeyword_2_0 = (Keyword)cUNKNOWNEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cERROREnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cERRORErrorKeyword_3_0 = (Keyword)cERROREnumLiteralDeclaration_3.eContents().get(0);
		
		//enum LogicValue:
		//	TRUE="true" | FALSE="false" | UNKNOWN="unknown" | ERROR="error";
		public EnumRule getRule() { return rule; }
		
		//TRUE="true" | FALSE="false" | UNKNOWN="unknown" | ERROR="error"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//TRUE="true"
		public EnumLiteralDeclaration getTRUEEnumLiteralDeclaration_0() { return cTRUEEnumLiteralDeclaration_0; }
		
		//"true"
		public Keyword getTRUETrueKeyword_0_0() { return cTRUETrueKeyword_0_0; }
		
		//FALSE="false"
		public EnumLiteralDeclaration getFALSEEnumLiteralDeclaration_1() { return cFALSEEnumLiteralDeclaration_1; }
		
		//"false"
		public Keyword getFALSEFalseKeyword_1_0() { return cFALSEFalseKeyword_1_0; }
		
		//UNKNOWN="unknown"
		public EnumLiteralDeclaration getUNKNOWNEnumLiteralDeclaration_2() { return cUNKNOWNEnumLiteralDeclaration_2; }
		
		//"unknown"
		public Keyword getUNKNOWNUnknownKeyword_2_0() { return cUNKNOWNUnknownKeyword_2_0; }
		
		//ERROR="error"
		public EnumLiteralDeclaration getERROREnumLiteralDeclaration_3() { return cERROREnumLiteralDeclaration_3; }
		
		//"error"
		public Keyword getERRORErrorKeyword_3_0() { return cERRORErrorKeyword_3_0; }
	}
	public class ObjectiveKindElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ObjectiveKind");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cMINIMIZATIONEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cMINIMIZATIONMinimizeKeyword_0_0 = (Keyword)cMINIMIZATIONEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMAXIMIZATIONEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMAXIMIZATIONMaximizeKeyword_1_0 = (Keyword)cMAXIMIZATIONEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum ObjectiveKind:
		//	MINIMIZATION="minimize" | MAXIMIZATION="maximize";
		public EnumRule getRule() { return rule; }
		
		//MINIMIZATION="minimize" | MAXIMIZATION="maximize"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//MINIMIZATION="minimize"
		public EnumLiteralDeclaration getMINIMIZATIONEnumLiteralDeclaration_0() { return cMINIMIZATIONEnumLiteralDeclaration_0; }
		
		//"minimize"
		public Keyword getMINIMIZATIONMinimizeKeyword_0_0() { return cMINIMIZATIONMinimizeKeyword_0_0; }
		
		//MAXIMIZATION="maximize"
		public EnumLiteralDeclaration getMAXIMIZATIONEnumLiteralDeclaration_1() { return cMAXIMIZATIONEnumLiteralDeclaration_1; }
		
		//"maximize"
		public Keyword getMAXIMIZATIONMaximizeKeyword_1_0() { return cMAXIMIZATIONMaximizeKeyword_1_0; }
	}
	
	private final ProblemElements pProblem;
	private final StatementElements pStatement;
	private final ImportElements pImport;
	private final UriImportElements pUriImport;
	private final NamespaceImportElements pNamespaceImport;
	private final AssertionOrDefinitionElements pAssertionOrDefinition;
	private final PredicateDefinitionElements pPredicateDefinition;
	private final UnnamedErrorPredicateDefintionElements pUnnamedErrorPredicateDefintion;
	private final DefaultAssertionElements pDefaultAssertion;
	private final FunctionDefinitionElements pFunctionDefinition;
	private final TypeReferenceElements pTypeReference;
	private final AttributeKindElements eAttributeKind;
	private final AttributeElements pAttribute;
	private final ExternDeclarationElements pExternDeclaration;
	private final ExternPredicateDeclarationElements pExternPredicateDeclaration;
	private final ExternFunctionDeclarationElements pExternFunctionDeclaration;
	private final ExternAggregationOperatorDeclarationElements pExternAggregationOperatorDeclaration;
	private final ExternDatatypeDeclarationElements pExternDatatypeDeclaration;
	private final ExpressionElements pExpression;
	private final ConditionalExpressionElements pConditionalExpression;
	private final LetExpressionElements pLetExpression;
	private final LetBindingElements pLetBinding;
	private final DisjunctiveExpressionElements pDisjunctiveExpression;
	private final CaseElements pCase;
	private final ConjunctiveExpressionElements pConjunctiveExpression;
	private final ComparisonOperatorElements eComparisonOperator;
	private final ComparisonExpressionElements pComparisonExpression;
	private final AdditiveBinaryOperatorElements eAdditiveBinaryOperator;
	private final AdditiveExpressionElements pAdditiveExpression;
	private final MultiplicativeBinaryOperatorElements eMultiplicativeBinaryOperator;
	private final MultiplicativeExpressionElements pMultiplicativeExpression;
	private final ExponentialOpElements eExponentialOp;
	private final ExponentialExpressionElements pExponentialExpression;
	private final CastExpressionElements pCastExpression;
	private final UnaryOperatorElements eUnaryOperator;
	private final UnaryExpressionElements pUnaryExpression;
	private final BracedAggregateExpressionElements pBracedAggregateExpression;
	private final AggregationElements pAggregation;
	private final CountElements pCount;
	private final AtomicExpressionElements pAtomicExpression;
	private final CallElements pCall;
	private final ArgumentListElements pArgumentList;
	private final ArgumentElements pArgument;
	private final ExpressionArgumentElements pExpressionArgument;
	private final StarArgumentElements pStarArgument;
	private final TypedVariableArgumentElements pTypedVariableArgument;
	private final TypedStarArgumentElements pTypedStarArgument;
	private final ReferenceElements pReference;
	private final PathComponentElements pPathComponent;
	private final IntervalElements pInterval;
	private final LiteralElements pLiteral;
	private final LogicValueElements eLogicValue;
	private final LogicLiteralElements pLogicLiteral;
	private final IntLiteralElements pIntLiteral;
	private final RealLiteralElements pRealLiteral;
	private final InfinityLiteralElements pInfinityLiteral;
	private final EmptyLiteralElements pEmptyLiteral;
	private final StringLiteralElements pStringLiteral;
	private final ClassDeclarationElements pClassDeclaration;
	private final FieldElements pField;
	private final MultiplicityElements pMultiplicity;
	private final UnboundedMultiplicityElements pUnboundedMultiplicity;
	private final ExactMultiplicityElements pExactMultiplicity;
	private final BoundedMultiplicityElements pBoundedMultiplicity;
	private final EnumDeclarationElements pEnumDeclaration;
	private final EnumLiteralElements pEnumLiteral;
	private final ScopeDeclarationElements pScopeDeclaration;
	private final ExactScopeElements pExactScope;
	private final BoundedScopeElements pBoundedScope;
	private final LowerBoundedScopeElements pLowerBoundedScope;
	private final ObjectiveKindElements eObjectiveKind;
	private final ObjectiveDeclarationElements pObjectiveDeclaration;
	private final UpperMultiplictyElements pUpperMultiplicty;
	private final RealElements pReal;
	private final QualifiedNameSegmentElements pQualifiedNameSegment;
	private final QualifiedNameElements pQualifiedName;
	private final TerminalRule tSTRING;
	private final TerminalRule tQUOTED_ID;
	private final TerminalRule tSL_COMMENT;
	private final TerminalRule tTRANSITIVE_CLOSURE;
	private final TerminalRule tREFLEXIVE_TRANSITIVE_CLOSURE;
	private final TerminalRule tFULL_STOP;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public SolverLanguageGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pProblem = new ProblemElements();
		this.pStatement = new StatementElements();
		this.pImport = new ImportElements();
		this.pUriImport = new UriImportElements();
		this.pNamespaceImport = new NamespaceImportElements();
		this.pAssertionOrDefinition = new AssertionOrDefinitionElements();
		this.pPredicateDefinition = new PredicateDefinitionElements();
		this.pUnnamedErrorPredicateDefintion = new UnnamedErrorPredicateDefintionElements();
		this.pDefaultAssertion = new DefaultAssertionElements();
		this.pFunctionDefinition = new FunctionDefinitionElements();
		this.pTypeReference = new TypeReferenceElements();
		this.eAttributeKind = new AttributeKindElements();
		this.pAttribute = new AttributeElements();
		this.pExternDeclaration = new ExternDeclarationElements();
		this.pExternPredicateDeclaration = new ExternPredicateDeclarationElements();
		this.pExternFunctionDeclaration = new ExternFunctionDeclarationElements();
		this.pExternAggregationOperatorDeclaration = new ExternAggregationOperatorDeclarationElements();
		this.pExternDatatypeDeclaration = new ExternDatatypeDeclarationElements();
		this.pExpression = new ExpressionElements();
		this.pConditionalExpression = new ConditionalExpressionElements();
		this.pLetExpression = new LetExpressionElements();
		this.pLetBinding = new LetBindingElements();
		this.pDisjunctiveExpression = new DisjunctiveExpressionElements();
		this.pCase = new CaseElements();
		this.pConjunctiveExpression = new ConjunctiveExpressionElements();
		this.eComparisonOperator = new ComparisonOperatorElements();
		this.pComparisonExpression = new ComparisonExpressionElements();
		this.eAdditiveBinaryOperator = new AdditiveBinaryOperatorElements();
		this.pAdditiveExpression = new AdditiveExpressionElements();
		this.eMultiplicativeBinaryOperator = new MultiplicativeBinaryOperatorElements();
		this.pMultiplicativeExpression = new MultiplicativeExpressionElements();
		this.eExponentialOp = new ExponentialOpElements();
		this.pExponentialExpression = new ExponentialExpressionElements();
		this.pCastExpression = new CastExpressionElements();
		this.eUnaryOperator = new UnaryOperatorElements();
		this.pUnaryExpression = new UnaryExpressionElements();
		this.pBracedAggregateExpression = new BracedAggregateExpressionElements();
		this.pAggregation = new AggregationElements();
		this.pCount = new CountElements();
		this.pAtomicExpression = new AtomicExpressionElements();
		this.pCall = new CallElements();
		this.pArgumentList = new ArgumentListElements();
		this.pArgument = new ArgumentElements();
		this.pExpressionArgument = new ExpressionArgumentElements();
		this.pStarArgument = new StarArgumentElements();
		this.pTypedVariableArgument = new TypedVariableArgumentElements();
		this.pTypedStarArgument = new TypedStarArgumentElements();
		this.pReference = new ReferenceElements();
		this.pPathComponent = new PathComponentElements();
		this.pInterval = new IntervalElements();
		this.pLiteral = new LiteralElements();
		this.eLogicValue = new LogicValueElements();
		this.pLogicLiteral = new LogicLiteralElements();
		this.pIntLiteral = new IntLiteralElements();
		this.pRealLiteral = new RealLiteralElements();
		this.pInfinityLiteral = new InfinityLiteralElements();
		this.pEmptyLiteral = new EmptyLiteralElements();
		this.pStringLiteral = new StringLiteralElements();
		this.pClassDeclaration = new ClassDeclarationElements();
		this.pField = new FieldElements();
		this.pMultiplicity = new MultiplicityElements();
		this.pUnboundedMultiplicity = new UnboundedMultiplicityElements();
		this.pExactMultiplicity = new ExactMultiplicityElements();
		this.pBoundedMultiplicity = new BoundedMultiplicityElements();
		this.pEnumDeclaration = new EnumDeclarationElements();
		this.pEnumLiteral = new EnumLiteralElements();
		this.pScopeDeclaration = new ScopeDeclarationElements();
		this.pExactScope = new ExactScopeElements();
		this.pBoundedScope = new BoundedScopeElements();
		this.pLowerBoundedScope = new LowerBoundedScopeElements();
		this.eObjectiveKind = new ObjectiveKindElements();
		this.pObjectiveDeclaration = new ObjectiveDeclarationElements();
		this.pUpperMultiplicty = new UpperMultiplictyElements();
		this.pReal = new RealElements();
		this.pQualifiedNameSegment = new QualifiedNameSegmentElements();
		this.pQualifiedName = new QualifiedNameElements();
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.STRING");
		this.tQUOTED_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.QUOTED_ID");
		this.tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.SL_COMMENT");
		this.tTRANSITIVE_CLOSURE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.TRANSITIVE_CLOSURE");
		this.tREFLEXIVE_TRANSITIVE_CLOSURE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.REFLEXIVE_TRANSITIVE_CLOSURE");
		this.tFULL_STOP = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.FULL_STOP");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.eclipse.viatra.solver.language.SolverLanguage".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Problem:
	//	("problem" name=QualifiedName FULL_STOP)?
	//	imports+=Import*
	//	statements+=Statement*;
	public ProblemElements getProblemAccess() {
		return pProblem;
	}
	
	public ParserRule getProblemRule() {
		return getProblemAccess().getRule();
	}
	
	//Statement:
	//	AssertionOrDefinition | PredicateDefinition | UnnamedErrorPredicateDefintion | DefaultAssertion | FunctionDefinition
	//	| Attribute | ExternDeclaration | ScopeDeclaration | ObjectiveDeclaration | ClassDeclaration | EnumDeclaration;
	public StatementElements getStatementAccess() {
		return pStatement;
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}
	
	//Import:
	//	UriImport | NamespaceImport;
	public ImportElements getImportAccess() {
		return pImport;
	}
	
	public ParserRule getImportRule() {
		return getImportAccess().getRule();
	}
	
	//UriImport:
	//	"import" uri=STRING ("as" alias=QualifiedName) FULL_STOP;
	public UriImportElements getUriImportAccess() {
		return pUriImport;
	}
	
	public ParserRule getUriImportRule() {
		return getUriImportAccess().getRule();
	}
	
	//NamespaceImport:
	//	"import" importedNamespace=QualifiedName ("as" alias=QualifiedName) FULL_STOP;
	public NamespaceImportElements getNamespaceImportAccess() {
		return pNamespaceImport;
	}
	
	public ParserRule getNamespaceImportRule() {
		return getNamespaceImportAccess().getRule();
	}
	
	//AssertionOrDefinition Statement:
	//	Expression ({Assertion.expression=current} (":" range=Expression)? | {PredicateDefinition.head=current} ":-"
	//	body=Expression | {FunctionDefinition.head=current} ":=" body=Expression) FULL_STOP;
	public AssertionOrDefinitionElements getAssertionOrDefinitionAccess() {
		return pAssertionOrDefinition;
	}
	
	public ParserRule getAssertionOrDefinitionRule() {
		return getAssertionOrDefinitionAccess().getRule();
	}
	
	//PredicateDefinition:
	//	(functional?="functional" error?="error"? | error?="error" functional?="functional"?) head=Call ":-" body=Expression
	//	FULL_STOP;
	public PredicateDefinitionElements getPredicateDefinitionAccess() {
		return pPredicateDefinition;
	}
	
	public ParserRule getPredicateDefinitionRule() {
		return getPredicateDefinitionAccess().getRule();
	}
	
	//UnnamedErrorPredicateDefintion:
	//	"error" argumentList=ArgumentList ":-" body=Expression FULL_STOP;
	public UnnamedErrorPredicateDefintionElements getUnnamedErrorPredicateDefintionAccess() {
		return pUnnamedErrorPredicateDefintion;
	}
	
	public ParserRule getUnnamedErrorPredicateDefintionRule() {
		return getUnnamedErrorPredicateDefintionAccess().getRule();
	}
	
	//DefaultAssertion:
	//	"default" expression=Call (":" range=Expression)? FULL_STOP;
	public DefaultAssertionElements getDefaultAssertionAccess() {
		return pDefaultAssertion;
	}
	
	public ParserRule getDefaultAssertionRule() {
		return getDefaultAssertionAccess().getRule();
	}
	
	//FunctionDefinition:
	//	resultType=[Symbol|QualifiedName] head=Call ":=" body=Expression FULL_STOP;
	public FunctionDefinitionElements getFunctionDefinitionAccess() {
		return pFunctionDefinition;
	}
	
	public ParserRule getFunctionDefinitionRule() {
		return getFunctionDefinitionAccess().getRule();
	}
	
	//TypeReference:
	//	type=[Symbol|QualifiedName] forceObjectType?="object"?;
	public TypeReferenceElements getTypeReferenceAccess() {
		return pTypeReference;
	}
	
	public ParserRule getTypeReferenceRule() {
		return getTypeReferenceAccess().getRule();
	}
	
	//enum AttributeKind:
	//	FUNCTIONAL="functional" | ERROR="error" | ROOT="root" | CONTAINMENT="containment";
	public AttributeKindElements getAttributeKindAccess() {
		return eAttributeKind;
	}
	
	public EnumRule getAttributeKindRule() {
		return getAttributeKindAccess().getRule();
	}
	
	//Attribute:
	//	kind=AttributeKind target=[Symbol|QualifiedName] FULL_STOP;
	public AttributeElements getAttributeAccess() {
		return pAttribute;
	}
	
	public ParserRule getAttributeRule() {
		return getAttributeAccess().getRule();
	}
	
	//ExternDeclaration:
	//	ExternPredicateDeclaration | ExternFunctionDeclaration | ExternAggregationOperatorDeclaration |
	//	ExternDatatypeDeclaration;
	public ExternDeclarationElements getExternDeclarationAccess() {
		return pExternDeclaration;
	}
	
	public ParserRule getExternDeclarationRule() {
		return getExternDeclarationAccess().getRule();
	}
	
	//ExternPredicateDeclaration:
	//	"extern" (functional?="functional"? & error?="error"?) name=QualifiedName argumentList=ArgumentList FULL_STOP;
	public ExternPredicateDeclarationElements getExternPredicateDeclarationAccess() {
		return pExternPredicateDeclaration;
	}
	
	public ParserRule getExternPredicateDeclarationRule() {
		return getExternPredicateDeclarationAccess().getRule();
	}
	
	//ExternFunctionDeclaration:
	//	"extern" resultType=[Symbol|QualifiedName] name=QualifiedName argumentList=ArgumentList FULL_STOP;
	public ExternFunctionDeclarationElements getExternFunctionDeclarationAccess() {
		return pExternFunctionDeclaration;
	}
	
	public ParserRule getExternFunctionDeclarationRule() {
		return getExternFunctionDeclarationAccess().getRule();
	}
	
	//ExternAggregationOperatorDeclaration:
	//	"extern" resultType=[Symbol|QualifiedName] name=QualifiedName "{" argumentType=[Symbol|QualifiedName] "..." "}"
	//	FULL_STOP;
	public ExternAggregationOperatorDeclarationElements getExternAggregationOperatorDeclarationAccess() {
		return pExternAggregationOperatorDeclaration;
	}
	
	public ParserRule getExternAggregationOperatorDeclarationRule() {
		return getExternAggregationOperatorDeclarationAccess().getRule();
	}
	
	//ExternDatatypeDeclaration:
	//	"extern" "datatype" name=QualifiedName FULL_STOP;
	public ExternDatatypeDeclarationElements getExternDatatypeDeclarationAccess() {
		return pExternDatatypeDeclaration;
	}
	
	public ParserRule getExternDatatypeDeclarationRule() {
		return getExternDatatypeDeclarationAccess().getRule();
	}
	
	//Expression:
	//	ConditionalExpression | LetExpression | DisjunctiveExpression ({Forall.condition=current} "=>"
	//	body=DisjunctiveExpression)?;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//ConditionalExpression:
	//	"if" condition=DisjunctiveExpression "then" then=Expression "else" else=Expression;
	public ConditionalExpressionElements getConditionalExpressionAccess() {
		return pConditionalExpression;
	}
	
	public ParserRule getConditionalExpressionRule() {
		return getConditionalExpressionAccess().getRule();
	}
	
	//LetExpression:
	//	"let" bindings+=LetBinding ("," bindings+=LetBinding)* "in" body=Expression;
	public LetExpressionElements getLetExpressionAccess() {
		return pLetExpression;
	}
	
	public ParserRule getLetExpressionRule() {
		return getLetExpressionAccess().getRule();
	}
	
	//LetBinding:
	//	type=[Symbol|QualifiedName]? name=ID "=" value=AdditiveExpression;
	public LetBindingElements getLetBindingAccess() {
		return pLetBinding;
	}
	
	public ParserRule getLetBindingRule() {
		return getLetBindingAccess().getRule();
	}
	
	//DisjunctiveExpression Expression:
	//	ConjunctiveExpression ({Disjunction.children+=current} (";" children+=ConjunctiveExpression)+ |
	//	{Case.condition=current} "->" body=ConjunctiveExpression {Switch.cases+=current} (";" cases+=Case)*)?;
	public DisjunctiveExpressionElements getDisjunctiveExpressionAccess() {
		return pDisjunctiveExpression;
	}
	
	public ParserRule getDisjunctiveExpressionRule() {
		return getDisjunctiveExpressionAccess().getRule();
	}
	
	//Case:
	//	condition=ConjunctiveExpression "->" body=ConjunctiveExpression;
	public CaseElements getCaseAccess() {
		return pCase;
	}
	
	public ParserRule getCaseRule() {
		return getCaseAccess().getRule();
	}
	
	//ConjunctiveExpression Expression:
	//	ComparisonExpression ({Conjunction.children+=current} ("," children+=ComparisonExpression)+)?;
	public ConjunctiveExpressionElements getConjunctiveExpressionAccess() {
		return pConjunctiveExpression;
	}
	
	public ParserRule getConjunctiveExpressionRule() {
		return getConjunctiveExpressionAccess().getRule();
	}
	
	//enum ComparisonOperator returns BinaryOperator:
	//	EQUALS="==" | NOT_EQUALS="!=" | LESS="<" | LESS_EQUALS="<=" | GREATER=">" | GREATER_EQUALS=">=" | IN="in";
	public ComparisonOperatorElements getComparisonOperatorAccess() {
		return eComparisonOperator;
	}
	
	public EnumRule getComparisonOperatorRule() {
		return getComparisonOperatorAccess().getRule();
	}
	
	//ComparisonExpression Expression:
	//	AdditiveExpression ({BinaryExpression.left=current} op=ComparisonOperator right=AdditiveExpression)?;
	public ComparisonExpressionElements getComparisonExpressionAccess() {
		return pComparisonExpression;
	}
	
	public ParserRule getComparisonExpressionRule() {
		return getComparisonExpressionAccess().getRule();
	}
	
	//enum AdditiveBinaryOperator returns BinaryOperator:
	//	PLUS="+" | MINUS="-";
	public AdditiveBinaryOperatorElements getAdditiveBinaryOperatorAccess() {
		return eAdditiveBinaryOperator;
	}
	
	public EnumRule getAdditiveBinaryOperatorRule() {
		return getAdditiveBinaryOperatorAccess().getRule();
	}
	
	//AdditiveExpression Expression:
	//	MultiplicativeExpression ({BinaryExpression.left=current} op=AdditiveBinaryOperator right=MultiplicativeExpression)*;
	public AdditiveExpressionElements getAdditiveExpressionAccess() {
		return pAdditiveExpression;
	}
	
	public ParserRule getAdditiveExpressionRule() {
		return getAdditiveExpressionAccess().getRule();
	}
	
	//enum MultiplicativeBinaryOperator returns BinaryOperator:
	//	MULTIPLY="*" | DIVIDE="/";
	public MultiplicativeBinaryOperatorElements getMultiplicativeBinaryOperatorAccess() {
		return eMultiplicativeBinaryOperator;
	}
	
	public EnumRule getMultiplicativeBinaryOperatorRule() {
		return getMultiplicativeBinaryOperatorAccess().getRule();
	}
	
	//MultiplicativeExpression Expression:
	//	ExponentialExpression ({BinaryExpression.left=current} op=MultiplicativeBinaryOperator right=ExponentialExpression)*;
	public MultiplicativeExpressionElements getMultiplicativeExpressionAccess() {
		return pMultiplicativeExpression;
	}
	
	public ParserRule getMultiplicativeExpressionRule() {
		return getMultiplicativeExpressionAccess().getRule();
	}
	
	//enum ExponentialOp returns BinaryOperator:
	//	POW="^";
	public ExponentialOpElements getExponentialOpAccess() {
		return eExponentialOp;
	}
	
	public EnumRule getExponentialOpRule() {
		return getExponentialOpAccess().getRule();
	}
	
	//ExponentialExpression Expression:
	//	CastExpression ({BinaryExpression.left=current} op=ExponentialOp right=CastExpression)?;
	public ExponentialExpressionElements getExponentialExpressionAccess() {
		return pExponentialExpression;
	}
	
	public ParserRule getExponentialExpressionRule() {
		return getExponentialExpressionAccess().getRule();
	}
	
	//CastExpression Expression:
	//	UnaryExpression ({CastExpression.body=current} "as" targetType=[Symbol|QualifiedName])?;
	public CastExpressionElements getCastExpressionAccess() {
		return pCastExpression;
	}
	
	public ParserRule getCastExpressionRule() {
		return getCastExpressionAccess().getRule();
	}
	
	//enum UnaryOperator:
	//	NOT="!" | PLUS="+" | MINUS="-" | MAYBE="?";
	public UnaryOperatorElements getUnaryOperatorAccess() {
		return eUnaryOperator;
	}
	
	public EnumRule getUnaryOperatorRule() {
		return getUnaryOperatorAccess().getRule();
	}
	
	//UnaryExpression Expression:
	//	BracedAggregateExpression | {UnaryExpression} op=UnaryOperator body=BracedAggregateExpression;
	public UnaryExpressionElements getUnaryExpressionAccess() {
		return pUnaryExpression;
	}
	
	public ParserRule getUnaryExpressionRule() {
		return getUnaryExpressionAccess().getRule();
	}
	
	//BracedAggregateExpression Expression:
	//	AtomicExpression | Aggregation | Count;
	public BracedAggregateExpressionElements getBracedAggregateExpressionAccess() {
		return pBracedAggregateExpression;
	}
	
	public ParserRule getBracedAggregateExpressionRule() {
		return getBracedAggregateExpressionAccess().getRule();
	}
	
	//Aggregation:
	//	op=[Symbol|QualifiedName] "{" value=Expression "|" condition=Expression "}";
	public AggregationElements getAggregationAccess() {
		return pAggregation;
	}
	
	public ParserRule getAggregationRule() {
		return getAggregationAccess().getRule();
	}
	
	//Count:
	//	"count" "{" condition=Expression "}";
	public CountElements getCountAccess() {
		return pCount;
	}
	
	public ParserRule getCountRule() {
		return getCountAccess().getRule();
	}
	
	//AtomicExpression Expression:
	//	Reference | Call | Interval | Literal | "(" Expression ")";
	public AtomicExpressionElements getAtomicExpressionAccess() {
		return pAtomicExpression;
	}
	
	public ParserRule getAtomicExpressionRule() {
		return getAtomicExpressionAccess().getRule();
	}
	
	//Call:
	//	functor=Reference argumentList=ArgumentList;
	public CallElements getCallAccess() {
		return pCall;
	}
	
	public ParserRule getCallRule() {
		return getCallAccess().getRule();
	}
	
	//ArgumentList:
	//	{ArgumentList} "(" (arguments+=Argument ("," arguments+=Argument)*)? ")";
	public ArgumentListElements getArgumentListAccess() {
		return pArgumentList;
	}
	
	public ParserRule getArgumentListRule() {
		return getArgumentListAccess().getRule();
	}
	
	//Argument:
	//	ExpressionArgument | StarArgument | TypedVariableArgument | TypedStarArgument;
	public ArgumentElements getArgumentAccess() {
		return pArgument;
	}
	
	public ParserRule getArgumentRule() {
		return getArgumentAccess().getRule();
	}
	
	//ExpressionArgument:
	//	expression=ComparisonExpression;
	public ExpressionArgumentElements getExpressionArgumentAccess() {
		return pExpressionArgument;
	}
	
	public ParserRule getExpressionArgumentRule() {
		return getExpressionArgumentAccess().getRule();
	}
	
	//StarArgument:
	//	{StarArgument} "*";
	public StarArgumentElements getStarArgumentAccess() {
		return pStarArgument;
	}
	
	public ParserRule getStarArgumentRule() {
		return getStarArgumentAccess().getRule();
	}
	
	//TypedVariableArgument:
	//	typeReference=TypeReference name=ID;
	public TypedVariableArgumentElements getTypedVariableArgumentAccess() {
		return pTypedVariableArgument;
	}
	
	public ParserRule getTypedVariableArgumentRule() {
		return getTypedVariableArgumentAccess().getRule();
	}
	
	//TypedStarArgument:
	//	typeReference=TypeReference "*";
	public TypedStarArgumentElements getTypedStarArgumentAccess() {
		return pTypedStarArgument;
	}
	
	public ParserRule getTypedStarArgumentRule() {
		return getTypedStarArgumentAccess().getRule();
	}
	
	//Reference:
	//	components+=PathComponent ("." components+=PathComponent)*;
	public ReferenceElements getReferenceAccess() {
		return pReference;
	}
	
	public ParserRule getReferenceRule() {
		return getReferenceAccess().getRule();
	}
	
	//PathComponent:
	//	inverse?="~"? symbol=[Symbol|QualifiedName] (transitiveClosure?=TRANSITIVE_CLOSURE |
	//	reflexiveTransitiveClosure?=REFLEXIVE_TRANSITIVE_CLOSURE)?;
	public PathComponentElements getPathComponentAccess() {
		return pPathComponent;
	}
	
	public ParserRule getPathComponentRule() {
		return getPathComponentAccess().getRule();
	}
	
	//Interval:
	//	"[" lowerBound=AdditiveExpression "," upperBound=AdditiveExpression "]";
	public IntervalElements getIntervalAccess() {
		return pInterval;
	}
	
	public ParserRule getIntervalRule() {
		return getIntervalAccess().getRule();
	}
	
	//Literal:
	//	LogicLiteral | IntLiteral | RealLiteral | InfinityLiteral | EmptyLiteral | StringLiteral;
	public LiteralElements getLiteralAccess() {
		return pLiteral;
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}
	
	//enum LogicValue:
	//	TRUE="true" | FALSE="false" | UNKNOWN="unknown" | ERROR="error";
	public LogicValueElements getLogicValueAccess() {
		return eLogicValue;
	}
	
	public EnumRule getLogicValueRule() {
		return getLogicValueAccess().getRule();
	}
	
	//LogicLiteral:
	//	value=LogicValue;
	public LogicLiteralElements getLogicLiteralAccess() {
		return pLogicLiteral;
	}
	
	public ParserRule getLogicLiteralRule() {
		return getLogicLiteralAccess().getRule();
	}
	
	//IntLiteral:
	//	value=INT;
	public IntLiteralElements getIntLiteralAccess() {
		return pIntLiteral;
	}
	
	public ParserRule getIntLiteralRule() {
		return getIntLiteralAccess().getRule();
	}
	
	//RealLiteral:
	//	value=Real;
	public RealLiteralElements getRealLiteralAccess() {
		return pRealLiteral;
	}
	
	public ParserRule getRealLiteralRule() {
		return getRealLiteralAccess().getRule();
	}
	
	//InfinityLiteral:
	//	{InfinityLiteral} "inf";
	public InfinityLiteralElements getInfinityLiteralAccess() {
		return pInfinityLiteral;
	}
	
	public ParserRule getInfinityLiteralRule() {
		return getInfinityLiteralAccess().getRule();
	}
	
	//EmptyLiteral:
	//	{EmptyLiteral} "empty";
	public EmptyLiteralElements getEmptyLiteralAccess() {
		return pEmptyLiteral;
	}
	
	public ParserRule getEmptyLiteralRule() {
		return getEmptyLiteralAccess().getRule();
	}
	
	//StringLiteral:
	//	value=STRING;
	public StringLiteralElements getStringLiteralAccess() {
		return pStringLiteral;
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}
	
	//ClassDeclaration:
	//	(abstract?="abstract"? & root?="root"?) "class" name=ID ("extends" supertypes+=[Symbol|QualifiedName] (","
	//	supertypes+=[Symbol|QualifiedName])*)? ("{" fields+=Field* "}" | FULL_STOP);
	public ClassDeclarationElements getClassDeclarationAccess() {
		return pClassDeclaration;
	}
	
	public ParserRule getClassDeclarationRule() {
		return getClassDeclarationAccess().getRule();
	}
	
	//Field:
	//	(containment?="contains" | crossReference?="refers")? type=[Symbol|QualifiedName] multiplicity=Multiplicity?
	//	name=ID ("opposite" opposite=[Symbol|QualifiedName])? ";"?;
	public FieldElements getFieldAccess() {
		return pField;
	}
	
	public ParserRule getFieldRule() {
		return getFieldAccess().getRule();
	}
	
	//Multiplicity:
	//	UnboundedMultiplicity | ExactMultiplicity | BoundedMultiplicity;
	public MultiplicityElements getMultiplicityAccess() {
		return pMultiplicity;
	}
	
	public ParserRule getMultiplicityRule() {
		return getMultiplicityAccess().getRule();
	}
	
	//UnboundedMultiplicity:
	//	{UnboundedMultiplicity} "[" "]";
	public UnboundedMultiplicityElements getUnboundedMultiplicityAccess() {
		return pUnboundedMultiplicity;
	}
	
	public ParserRule getUnboundedMultiplicityRule() {
		return getUnboundedMultiplicityAccess().getRule();
	}
	
	//ExactMultiplicity:
	//	"[" value=UpperMultiplicty "]";
	public ExactMultiplicityElements getExactMultiplicityAccess() {
		return pExactMultiplicity;
	}
	
	public ParserRule getExactMultiplicityRule() {
		return getExactMultiplicityAccess().getRule();
	}
	
	//BoundedMultiplicity:
	//	"[" lowerBound=INT "," upperBound=UpperMultiplicty "]";
	public BoundedMultiplicityElements getBoundedMultiplicityAccess() {
		return pBoundedMultiplicity;
	}
	
	public ParserRule getBoundedMultiplicityRule() {
		return getBoundedMultiplicityAccess().getRule();
	}
	
	//EnumDeclaration:
	//	"enum" name=ID ("{" (literals+=EnumLiteral (","? literals+=EnumLiteral)*)? "}" | FULL_STOP);
	public EnumDeclarationElements getEnumDeclarationAccess() {
		return pEnumDeclaration;
	}
	
	public ParserRule getEnumDeclarationRule() {
		return getEnumDeclarationAccess().getRule();
	}
	
	//EnumLiteral:
	//	name=ID;
	public EnumLiteralElements getEnumLiteralAccess() {
		return pEnumLiteral;
	}
	
	public ParserRule getEnumLiteralRule() {
		return getEnumLiteralAccess().getRule();
	}
	
	//ScopeDeclaration:
	//	ExactScope | BoundedScope | LowerBoundedScope;
	public ScopeDeclarationElements getScopeDeclarationAccess() {
		return pScopeDeclaration;
	}
	
	public ParserRule getScopeDeclarationRule() {
		return getScopeDeclarationAccess().getRule();
	}
	
	//ExactScope:
	//	"scope" type=[Symbol|QualifiedName] "==" size=INT FULL_STOP;
	public ExactScopeElements getExactScopeAccess() {
		return pExactScope;
	}
	
	public ParserRule getExactScopeRule() {
		return getExactScopeAccess().getRule();
	}
	
	//BoundedScope:
	//	"scope" ((lowerBound=INT "<=")? type=[Symbol|QualifiedName] "<=" upperBound=INT | upperBound=INT ">="
	//	type=[Symbol|QualifiedName] (">=" lowerBound=INT)?) FULL_STOP;
	public BoundedScopeElements getBoundedScopeAccess() {
		return pBoundedScope;
	}
	
	public ParserRule getBoundedScopeRule() {
		return getBoundedScopeAccess().getRule();
	}
	
	//LowerBoundedScope:
	//	"scope" (lowerBound=INT "<=" type=[Symbol|QualifiedName] | type=[Symbol|QualifiedName] ">=" lowerBound=INT)
	//	FULL_STOP;
	public LowerBoundedScopeElements getLowerBoundedScopeAccess() {
		return pLowerBoundedScope;
	}
	
	public ParserRule getLowerBoundedScopeRule() {
		return getLowerBoundedScopeAccess().getRule();
	}
	
	//enum ObjectiveKind:
	//	MINIMIZATION="minimize" | MAXIMIZATION="maximize";
	public ObjectiveKindElements getObjectiveKindAccess() {
		return eObjectiveKind;
	}
	
	public EnumRule getObjectiveKindRule() {
		return getObjectiveKindAccess().getRule();
	}
	
	//ObjectiveDeclaration:
	//	kind=ObjectiveKind objective=Expression FULL_STOP;
	public ObjectiveDeclarationElements getObjectiveDeclarationAccess() {
		return pObjectiveDeclaration;
	}
	
	public ParserRule getObjectiveDeclarationRule() {
		return getObjectiveDeclarationAccess().getRule();
	}
	
	//UpperMultiplicty ecore::EInt:
	//	INT | "*";
	public UpperMultiplictyElements getUpperMultiplictyAccess() {
		return pUpperMultiplicty;
	}
	
	public ParserRule getUpperMultiplictyRule() {
		return getUpperMultiplictyAccess().getRule();
	}
	
	//Real ecore::EBigDecimal hidden():
	//	INT "." INT;
	public RealElements getRealAccess() {
		return pReal;
	}
	
	public ParserRule getRealRule() {
		return getRealAccess().getRule();
	}
	
	//QualifiedNameSegment:
	//	ID | QUOTED_ID | "object";
	public QualifiedNameSegmentElements getQualifiedNameSegmentAccess() {
		return pQualifiedNameSegment;
	}
	
	public ParserRule getQualifiedNameSegmentRule() {
		return getQualifiedNameSegmentAccess().getRule();
	}
	
	//QualifiedName hidden():
	//	QualifiedNameSegment ("::" QualifiedNameSegment)*;
	public QualifiedNameElements getQualifiedNameAccess() {
		return pQualifiedName;
	}
	
	public ParserRule getQualifiedNameRule() {
		return getQualifiedNameAccess().getRule();
	}
	
	//@ Override terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"';
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	}
	
	//terminal QUOTED_ID:
	//	'\'' ('\\' . | !('\\' | '\''))* '\'';
	public TerminalRule getQUOTED_IDRule() {
		return tQUOTED_ID;
	}
	
	//@ Override terminal SL_COMMENT:
	//	('%' | '//') !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return tSL_COMMENT;
	}
	
	//terminal TRANSITIVE_CLOSURE:
	//	"synthetic:TRANSITIVE_CLOSURE";
	public TerminalRule getTRANSITIVE_CLOSURERule() {
		return tTRANSITIVE_CLOSURE;
	}
	
	//terminal REFLEXIVE_TRANSITIVE_CLOSURE:
	//	"synthetic:REFLEXIVE_TRANSITIVE_CLOSURE";
	public TerminalRule getREFLEXIVE_TRANSITIVE_CLOSURERule() {
		return tREFLEXIVE_TRANSITIVE_CLOSURE;
	}
	
	//terminal FULL_STOP:
	//	"synthetic:FULL_STOP";
	public TerminalRule getFULL_STOPRule() {
		return tFULL_STOP;
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
