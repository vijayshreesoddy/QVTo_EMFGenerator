/*
 * generated by Xtext 2.12.0
 */
package org.eclipse.viatra.solver.language.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.viatra.solver.language.services.SolverLanguageGrammarAccess;
import org.eclipse.viatra.solver.language.solverLanguage.Aggregation;
import org.eclipse.viatra.solver.language.solverLanguage.ArgumentList;
import org.eclipse.viatra.solver.language.solverLanguage.Assertion;
import org.eclipse.viatra.solver.language.solverLanguage.Attribute;
import org.eclipse.viatra.solver.language.solverLanguage.BinaryExpression;
import org.eclipse.viatra.solver.language.solverLanguage.BoundedMultiplicity;
import org.eclipse.viatra.solver.language.solverLanguage.BoundedScope;
import org.eclipse.viatra.solver.language.solverLanguage.Call;
import org.eclipse.viatra.solver.language.solverLanguage.Case;
import org.eclipse.viatra.solver.language.solverLanguage.CastExpression;
import org.eclipse.viatra.solver.language.solverLanguage.ClassDeclaration;
import org.eclipse.viatra.solver.language.solverLanguage.ConditionalExpression;
import org.eclipse.viatra.solver.language.solverLanguage.Conjunction;
import org.eclipse.viatra.solver.language.solverLanguage.Count;
import org.eclipse.viatra.solver.language.solverLanguage.DefaultAssertion;
import org.eclipse.viatra.solver.language.solverLanguage.Disjunction;
import org.eclipse.viatra.solver.language.solverLanguage.EmptyLiteral;
import org.eclipse.viatra.solver.language.solverLanguage.EnumDeclaration;
import org.eclipse.viatra.solver.language.solverLanguage.EnumLiteral;
import org.eclipse.viatra.solver.language.solverLanguage.ExactMultiplicity;
import org.eclipse.viatra.solver.language.solverLanguage.ExactScope;
import org.eclipse.viatra.solver.language.solverLanguage.ExpressionArgument;
import org.eclipse.viatra.solver.language.solverLanguage.ExternAggregationOperatorDeclaration;
import org.eclipse.viatra.solver.language.solverLanguage.ExternDatatypeDeclaration;
import org.eclipse.viatra.solver.language.solverLanguage.ExternFunctionDeclaration;
import org.eclipse.viatra.solver.language.solverLanguage.ExternPredicateDeclaration;
import org.eclipse.viatra.solver.language.solverLanguage.Field;
import org.eclipse.viatra.solver.language.solverLanguage.Forall;
import org.eclipse.viatra.solver.language.solverLanguage.FunctionDefinition;
import org.eclipse.viatra.solver.language.solverLanguage.InfinityLiteral;
import org.eclipse.viatra.solver.language.solverLanguage.IntLiteral;
import org.eclipse.viatra.solver.language.solverLanguage.Interval;
import org.eclipse.viatra.solver.language.solverLanguage.LetBinding;
import org.eclipse.viatra.solver.language.solverLanguage.LetExpression;
import org.eclipse.viatra.solver.language.solverLanguage.LogicLiteral;
import org.eclipse.viatra.solver.language.solverLanguage.LowerBoundedScope;
import org.eclipse.viatra.solver.language.solverLanguage.NamespaceImport;
import org.eclipse.viatra.solver.language.solverLanguage.ObjectiveDeclaration;
import org.eclipse.viatra.solver.language.solverLanguage.PathComponent;
import org.eclipse.viatra.solver.language.solverLanguage.PredicateDefinition;
import org.eclipse.viatra.solver.language.solverLanguage.Problem;
import org.eclipse.viatra.solver.language.solverLanguage.RealLiteral;
import org.eclipse.viatra.solver.language.solverLanguage.Reference;
import org.eclipse.viatra.solver.language.solverLanguage.SolverLanguagePackage;
import org.eclipse.viatra.solver.language.solverLanguage.StarArgument;
import org.eclipse.viatra.solver.language.solverLanguage.StringLiteral;
import org.eclipse.viatra.solver.language.solverLanguage.Switch;
import org.eclipse.viatra.solver.language.solverLanguage.TypeReference;
import org.eclipse.viatra.solver.language.solverLanguage.TypedStarArgument;
import org.eclipse.viatra.solver.language.solverLanguage.TypedVariableArgument;
import org.eclipse.viatra.solver.language.solverLanguage.UnaryExpression;
import org.eclipse.viatra.solver.language.solverLanguage.UnboundedMultiplicity;
import org.eclipse.viatra.solver.language.solverLanguage.UnnamedErrorPredicateDefintion;
import org.eclipse.viatra.solver.language.solverLanguage.UriImport;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class SolverLanguageSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SolverLanguageGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SolverLanguagePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SolverLanguagePackage.AGGREGATION:
				sequence_Aggregation(context, (Aggregation) semanticObject); 
				return; 
			case SolverLanguagePackage.ARGUMENT_LIST:
				sequence_ArgumentList(context, (ArgumentList) semanticObject); 
				return; 
			case SolverLanguagePackage.ASSERTION:
				sequence_AssertionOrDefinition(context, (Assertion) semanticObject); 
				return; 
			case SolverLanguagePackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case SolverLanguagePackage.BINARY_EXPRESSION:
				sequence_AdditiveExpression_ComparisonExpression_ExponentialExpression_MultiplicativeExpression(context, (BinaryExpression) semanticObject); 
				return; 
			case SolverLanguagePackage.BOUNDED_MULTIPLICITY:
				sequence_BoundedMultiplicity(context, (BoundedMultiplicity) semanticObject); 
				return; 
			case SolverLanguagePackage.BOUNDED_SCOPE:
				sequence_BoundedScope(context, (BoundedScope) semanticObject); 
				return; 
			case SolverLanguagePackage.CALL:
				sequence_Call(context, (Call) semanticObject); 
				return; 
			case SolverLanguagePackage.CASE:
				if (rule == grammarAccess.getCaseRule()) {
					sequence_Case(context, (Case) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getDisjunctiveExpressionAccess().getSwitchCasesAction_1_1_3()) {
					sequence_DisjunctiveExpression_Switch_1_1_3(context, (Case) semanticObject); 
					return; 
				}
				else break;
			case SolverLanguagePackage.CAST_EXPRESSION:
				sequence_CastExpression(context, (CastExpression) semanticObject); 
				return; 
			case SolverLanguagePackage.CLASS_DECLARATION:
				sequence_ClassDeclaration(context, (ClassDeclaration) semanticObject); 
				return; 
			case SolverLanguagePackage.CONDITIONAL_EXPRESSION:
				sequence_ConditionalExpression(context, (ConditionalExpression) semanticObject); 
				return; 
			case SolverLanguagePackage.CONJUNCTION:
				sequence_ConjunctiveExpression(context, (Conjunction) semanticObject); 
				return; 
			case SolverLanguagePackage.COUNT:
				sequence_Count(context, (Count) semanticObject); 
				return; 
			case SolverLanguagePackage.DEFAULT_ASSERTION:
				sequence_DefaultAssertion(context, (DefaultAssertion) semanticObject); 
				return; 
			case SolverLanguagePackage.DISJUNCTION:
				sequence_DisjunctiveExpression(context, (Disjunction) semanticObject); 
				return; 
			case SolverLanguagePackage.EMPTY_LITERAL:
				sequence_EmptyLiteral(context, (EmptyLiteral) semanticObject); 
				return; 
			case SolverLanguagePackage.ENUM_DECLARATION:
				sequence_EnumDeclaration(context, (EnumDeclaration) semanticObject); 
				return; 
			case SolverLanguagePackage.ENUM_LITERAL:
				sequence_EnumLiteral(context, (EnumLiteral) semanticObject); 
				return; 
			case SolverLanguagePackage.EXACT_MULTIPLICITY:
				sequence_ExactMultiplicity(context, (ExactMultiplicity) semanticObject); 
				return; 
			case SolverLanguagePackage.EXACT_SCOPE:
				sequence_ExactScope(context, (ExactScope) semanticObject); 
				return; 
			case SolverLanguagePackage.EXPRESSION_ARGUMENT:
				sequence_ExpressionArgument(context, (ExpressionArgument) semanticObject); 
				return; 
			case SolverLanguagePackage.EXTERN_AGGREGATION_OPERATOR_DECLARATION:
				sequence_ExternAggregationOperatorDeclaration(context, (ExternAggregationOperatorDeclaration) semanticObject); 
				return; 
			case SolverLanguagePackage.EXTERN_DATATYPE_DECLARATION:
				sequence_ExternDatatypeDeclaration(context, (ExternDatatypeDeclaration) semanticObject); 
				return; 
			case SolverLanguagePackage.EXTERN_FUNCTION_DECLARATION:
				sequence_ExternFunctionDeclaration(context, (ExternFunctionDeclaration) semanticObject); 
				return; 
			case SolverLanguagePackage.EXTERN_PREDICATE_DECLARATION:
				sequence_ExternPredicateDeclaration(context, (ExternPredicateDeclaration) semanticObject); 
				return; 
			case SolverLanguagePackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case SolverLanguagePackage.FORALL:
				sequence_Expression(context, (Forall) semanticObject); 
				return; 
			case SolverLanguagePackage.FUNCTION_DEFINITION:
				if (rule == grammarAccess.getAssertionOrDefinitionRule()) {
					sequence_AssertionOrDefinition(context, (FunctionDefinition) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_AssertionOrDefinition_FunctionDefinition(context, (FunctionDefinition) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFunctionDefinitionRule()) {
					sequence_FunctionDefinition(context, (FunctionDefinition) semanticObject); 
					return; 
				}
				else break;
			case SolverLanguagePackage.INFINITY_LITERAL:
				sequence_InfinityLiteral(context, (InfinityLiteral) semanticObject); 
				return; 
			case SolverLanguagePackage.INT_LITERAL:
				sequence_IntLiteral(context, (IntLiteral) semanticObject); 
				return; 
			case SolverLanguagePackage.INTERVAL:
				sequence_Interval(context, (Interval) semanticObject); 
				return; 
			case SolverLanguagePackage.LET_BINDING:
				sequence_LetBinding(context, (LetBinding) semanticObject); 
				return; 
			case SolverLanguagePackage.LET_EXPRESSION:
				sequence_LetExpression(context, (LetExpression) semanticObject); 
				return; 
			case SolverLanguagePackage.LOGIC_LITERAL:
				sequence_LogicLiteral(context, (LogicLiteral) semanticObject); 
				return; 
			case SolverLanguagePackage.LOWER_BOUNDED_SCOPE:
				sequence_LowerBoundedScope(context, (LowerBoundedScope) semanticObject); 
				return; 
			case SolverLanguagePackage.NAMESPACE_IMPORT:
				sequence_NamespaceImport(context, (NamespaceImport) semanticObject); 
				return; 
			case SolverLanguagePackage.OBJECTIVE_DECLARATION:
				sequence_ObjectiveDeclaration(context, (ObjectiveDeclaration) semanticObject); 
				return; 
			case SolverLanguagePackage.PATH_COMPONENT:
				sequence_PathComponent(context, (PathComponent) semanticObject); 
				return; 
			case SolverLanguagePackage.PREDICATE_DEFINITION:
				if (rule == grammarAccess.getAssertionOrDefinitionRule()) {
					sequence_AssertionOrDefinition(context, (PredicateDefinition) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_AssertionOrDefinition_PredicateDefinition(context, (PredicateDefinition) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPredicateDefinitionRule()) {
					sequence_PredicateDefinition(context, (PredicateDefinition) semanticObject); 
					return; 
				}
				else break;
			case SolverLanguagePackage.PROBLEM:
				sequence_Problem(context, (Problem) semanticObject); 
				return; 
			case SolverLanguagePackage.REAL_LITERAL:
				sequence_RealLiteral(context, (RealLiteral) semanticObject); 
				return; 
			case SolverLanguagePackage.REFERENCE:
				sequence_Reference(context, (Reference) semanticObject); 
				return; 
			case SolverLanguagePackage.STAR_ARGUMENT:
				sequence_StarArgument(context, (StarArgument) semanticObject); 
				return; 
			case SolverLanguagePackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case SolverLanguagePackage.SWITCH:
				sequence_DisjunctiveExpression(context, (Switch) semanticObject); 
				return; 
			case SolverLanguagePackage.TYPE_REFERENCE:
				sequence_TypeReference(context, (TypeReference) semanticObject); 
				return; 
			case SolverLanguagePackage.TYPED_STAR_ARGUMENT:
				sequence_TypedStarArgument(context, (TypedStarArgument) semanticObject); 
				return; 
			case SolverLanguagePackage.TYPED_VARIABLE_ARGUMENT:
				sequence_TypedVariableArgument(context, (TypedVariableArgument) semanticObject); 
				return; 
			case SolverLanguagePackage.UNARY_EXPRESSION:
				sequence_UnaryExpression(context, (UnaryExpression) semanticObject); 
				return; 
			case SolverLanguagePackage.UNBOUNDED_MULTIPLICITY:
				sequence_UnboundedMultiplicity(context, (UnboundedMultiplicity) semanticObject); 
				return; 
			case SolverLanguagePackage.UNNAMED_ERROR_PREDICATE_DEFINTION:
				sequence_UnnamedErrorPredicateDefintion(context, (UnnamedErrorPredicateDefintion) semanticObject); 
				return; 
			case SolverLanguagePackage.URI_IMPORT:
				sequence_UriImport(context, (UriImport) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AssertionOrDefinition.Assertion_1_0_0 returns BinaryExpression
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns BinaryExpression
	 *     AssertionOrDefinition.FunctionDefinition_1_2_0 returns BinaryExpression
	 *     Expression returns BinaryExpression
	 *     Expression.Forall_2_1_0 returns BinaryExpression
	 *     DisjunctiveExpression returns BinaryExpression
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns BinaryExpression
	 *     DisjunctiveExpression.Case_1_1_0 returns BinaryExpression
	 *     ConjunctiveExpression returns BinaryExpression
	 *     ConjunctiveExpression.Conjunction_1_0 returns BinaryExpression
	 *     ComparisonExpression returns BinaryExpression
	 *     ComparisonExpression.BinaryExpression_1_0 returns BinaryExpression
	 *     AdditiveExpression returns BinaryExpression
	 *     AdditiveExpression.BinaryExpression_1_0 returns BinaryExpression
	 *     MultiplicativeExpression returns BinaryExpression
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns BinaryExpression
	 *     ExponentialExpression returns BinaryExpression
	 *     ExponentialExpression.BinaryExpression_1_0 returns BinaryExpression
	 *     CastExpression returns BinaryExpression
	 *     CastExpression.CastExpression_1_0 returns BinaryExpression
	 *     UnaryExpression returns BinaryExpression
	 *     BracedAggregateExpression returns BinaryExpression
	 *     AtomicExpression returns BinaryExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=ComparisonExpression_BinaryExpression_1_0 op=ComparisonOperator right=AdditiveExpression) | 
	 *         (left=AdditiveExpression_BinaryExpression_1_0 op=AdditiveBinaryOperator right=MultiplicativeExpression) | 
	 *         (left=MultiplicativeExpression_BinaryExpression_1_0 op=MultiplicativeBinaryOperator right=ExponentialExpression) | 
	 *         (left=ExponentialExpression_BinaryExpression_1_0 op=ExponentialOp right=CastExpression)
	 *     )
	 */
	protected void sequence_AdditiveExpression_ComparisonExpression_ExponentialExpression_MultiplicativeExpression(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssertionOrDefinition.Assertion_1_0_0 returns Aggregation
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns Aggregation
	 *     AssertionOrDefinition.FunctionDefinition_1_2_0 returns Aggregation
	 *     Expression returns Aggregation
	 *     Expression.Forall_2_1_0 returns Aggregation
	 *     DisjunctiveExpression returns Aggregation
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns Aggregation
	 *     DisjunctiveExpression.Case_1_1_0 returns Aggregation
	 *     ConjunctiveExpression returns Aggregation
	 *     ConjunctiveExpression.Conjunction_1_0 returns Aggregation
	 *     ComparisonExpression returns Aggregation
	 *     ComparisonExpression.BinaryExpression_1_0 returns Aggregation
	 *     AdditiveExpression returns Aggregation
	 *     AdditiveExpression.BinaryExpression_1_0 returns Aggregation
	 *     MultiplicativeExpression returns Aggregation
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns Aggregation
	 *     ExponentialExpression returns Aggregation
	 *     ExponentialExpression.BinaryExpression_1_0 returns Aggregation
	 *     CastExpression returns Aggregation
	 *     CastExpression.CastExpression_1_0 returns Aggregation
	 *     UnaryExpression returns Aggregation
	 *     BracedAggregateExpression returns Aggregation
	 *     Aggregation returns Aggregation
	 *     AtomicExpression returns Aggregation
	 *
	 * Constraint:
	 *     (op=[Symbol|QualifiedName] value=Expression condition=Expression)
	 */
	protected void sequence_Aggregation(ISerializationContext context, Aggregation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.AGGREGATION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.AGGREGATION__OP));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.AGGREGATION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.AGGREGATION__VALUE));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.AGGREGATE_EXPRESSION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.AGGREGATE_EXPRESSION__CONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAggregationAccess().getOpSymbolQualifiedNameParserRuleCall_0_0_1(), semanticObject.eGet(SolverLanguagePackage.Literals.AGGREGATION__OP, false));
		feeder.accept(grammarAccess.getAggregationAccess().getValueExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getAggregationAccess().getConditionExpressionParserRuleCall_4_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArgumentList returns ArgumentList
	 *
	 * Constraint:
	 *     (arguments+=Argument arguments+=Argument*)?
	 */
	protected void sequence_ArgumentList(ISerializationContext context, ArgumentList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Assertion
	 *     AssertionOrDefinition returns Assertion
	 *
	 * Constraint:
	 *     (expression=AssertionOrDefinition_Assertion_1_0_0 range=Expression?)
	 */
	protected void sequence_AssertionOrDefinition(ISerializationContext context, Assertion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssertionOrDefinition returns FunctionDefinition
	 *
	 * Constraint:
	 *     (head=AssertionOrDefinition_FunctionDefinition_1_2_0 body=Expression)
	 */
	protected void sequence_AssertionOrDefinition(ISerializationContext context, FunctionDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.FUNCTOR_DEFINITON__HEAD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.FUNCTOR_DEFINITON__HEAD));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.FUNCTOR_DEFINITON__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.FUNCTOR_DEFINITON__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssertionOrDefinitionAccess().getFunctionDefinitionHeadAction_1_2_0(), semanticObject.getHead());
		feeder.accept(grammarAccess.getAssertionOrDefinitionAccess().getBodyExpressionParserRuleCall_1_2_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns FunctionDefinition
	 *
	 * Constraint:
	 *     ((head=AssertionOrDefinition_FunctionDefinition_1_2_0 body=Expression) | (resultType=[Symbol|QualifiedName] head=Call body=Expression))
	 */
	protected void sequence_AssertionOrDefinition_FunctionDefinition(ISerializationContext context, FunctionDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssertionOrDefinition returns PredicateDefinition
	 *
	 * Constraint:
	 *     (head=AssertionOrDefinition_PredicateDefinition_1_1_0 body=Expression)
	 */
	protected void sequence_AssertionOrDefinition(ISerializationContext context, PredicateDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.FUNCTOR_DEFINITON__HEAD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.FUNCTOR_DEFINITON__HEAD));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.FUNCTOR_DEFINITON__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.FUNCTOR_DEFINITON__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssertionOrDefinitionAccess().getPredicateDefinitionHeadAction_1_1_0(), semanticObject.getHead());
		feeder.accept(grammarAccess.getAssertionOrDefinitionAccess().getBodyExpressionParserRuleCall_1_1_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns PredicateDefinition
	 *
	 * Constraint:
	 *     (
	 *         (head=AssertionOrDefinition_PredicateDefinition_1_1_0 body=Expression) | 
	 *         (((functional?='functional' error?='error'?) | (error?='error' functional?='functional'?)) head=Call body=Expression)
	 *     )
	 */
	protected void sequence_AssertionOrDefinition_PredicateDefinition(ISerializationContext context, PredicateDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Attribute
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (kind=AttributeKind target=[Symbol|QualifiedName])
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.ATTRIBUTE__KIND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.ATTRIBUTE__KIND));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.ATTRIBUTE__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.ATTRIBUTE__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeAccess().getKindAttributeKindEnumRuleCall_0_0(), semanticObject.getKind());
		feeder.accept(grammarAccess.getAttributeAccess().getTargetSymbolQualifiedNameParserRuleCall_1_0_1(), semanticObject.eGet(SolverLanguagePackage.Literals.ATTRIBUTE__TARGET, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Multiplicity returns BoundedMultiplicity
	 *     BoundedMultiplicity returns BoundedMultiplicity
	 *
	 * Constraint:
	 *     (lowerBound=INT upperBound=UpperMultiplicty)
	 */
	protected void sequence_BoundedMultiplicity(ISerializationContext context, BoundedMultiplicity semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.BOUNDED_MULTIPLICITY__LOWER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.BOUNDED_MULTIPLICITY__LOWER_BOUND));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.BOUNDED_MULTIPLICITY__UPPER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.BOUNDED_MULTIPLICITY__UPPER_BOUND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoundedMultiplicityAccess().getLowerBoundINTTerminalRuleCall_1_0(), semanticObject.getLowerBound());
		feeder.accept(grammarAccess.getBoundedMultiplicityAccess().getUpperBoundUpperMultiplictyParserRuleCall_3_0(), semanticObject.getUpperBound());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BoundedScope
	 *     ScopeDeclaration returns BoundedScope
	 *     BoundedScope returns BoundedScope
	 *
	 * Constraint:
	 *     ((lowerBound=INT? type=[Symbol|QualifiedName] upperBound=INT) | (upperBound=INT type=[Symbol|QualifiedName] lowerBound=INT?))
	 */
	protected void sequence_BoundedScope(ISerializationContext context, BoundedScope semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssertionOrDefinition.Assertion_1_0_0 returns Call
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns Call
	 *     AssertionOrDefinition.FunctionDefinition_1_2_0 returns Call
	 *     Expression returns Call
	 *     Expression.Forall_2_1_0 returns Call
	 *     DisjunctiveExpression returns Call
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns Call
	 *     DisjunctiveExpression.Case_1_1_0 returns Call
	 *     ConjunctiveExpression returns Call
	 *     ConjunctiveExpression.Conjunction_1_0 returns Call
	 *     ComparisonExpression returns Call
	 *     ComparisonExpression.BinaryExpression_1_0 returns Call
	 *     AdditiveExpression returns Call
	 *     AdditiveExpression.BinaryExpression_1_0 returns Call
	 *     MultiplicativeExpression returns Call
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns Call
	 *     ExponentialExpression returns Call
	 *     ExponentialExpression.BinaryExpression_1_0 returns Call
	 *     CastExpression returns Call
	 *     CastExpression.CastExpression_1_0 returns Call
	 *     UnaryExpression returns Call
	 *     BracedAggregateExpression returns Call
	 *     AtomicExpression returns Call
	 *     Call returns Call
	 *
	 * Constraint:
	 *     (functor=Reference argumentList=ArgumentList)
	 */
	protected void sequence_Call(ISerializationContext context, Call semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.CALL__FUNCTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.CALL__FUNCTOR));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.CALL__ARGUMENT_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.CALL__ARGUMENT_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCallAccess().getFunctorReferenceParserRuleCall_0_0(), semanticObject.getFunctor());
		feeder.accept(grammarAccess.getCallAccess().getArgumentListArgumentListParserRuleCall_1_0(), semanticObject.getArgumentList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Case returns Case
	 *
	 * Constraint:
	 *     (condition=ConjunctiveExpression body=ConjunctiveExpression)
	 */
	protected void sequence_Case(ISerializationContext context, Case semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.CASE__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.CASE__CONDITION));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.CASE__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.CASE__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCaseAccess().getConditionConjunctiveExpressionParserRuleCall_0_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getCaseAccess().getBodyConjunctiveExpressionParserRuleCall_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AssertionOrDefinition.Assertion_1_0_0 returns CastExpression
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns CastExpression
	 *     AssertionOrDefinition.FunctionDefinition_1_2_0 returns CastExpression
	 *     Expression returns CastExpression
	 *     Expression.Forall_2_1_0 returns CastExpression
	 *     DisjunctiveExpression returns CastExpression
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns CastExpression
	 *     DisjunctiveExpression.Case_1_1_0 returns CastExpression
	 *     ConjunctiveExpression returns CastExpression
	 *     ConjunctiveExpression.Conjunction_1_0 returns CastExpression
	 *     ComparisonExpression returns CastExpression
	 *     ComparisonExpression.BinaryExpression_1_0 returns CastExpression
	 *     AdditiveExpression returns CastExpression
	 *     AdditiveExpression.BinaryExpression_1_0 returns CastExpression
	 *     MultiplicativeExpression returns CastExpression
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns CastExpression
	 *     ExponentialExpression returns CastExpression
	 *     ExponentialExpression.BinaryExpression_1_0 returns CastExpression
	 *     CastExpression returns CastExpression
	 *     CastExpression.CastExpression_1_0 returns CastExpression
	 *     UnaryExpression returns CastExpression
	 *     BracedAggregateExpression returns CastExpression
	 *     AtomicExpression returns CastExpression
	 *
	 * Constraint:
	 *     (body=CastExpression_CastExpression_1_0 targetType=[Symbol|QualifiedName])
	 */
	protected void sequence_CastExpression(ISerializationContext context, CastExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.CAST_EXPRESSION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.CAST_EXPRESSION__BODY));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.CAST_EXPRESSION__TARGET_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.CAST_EXPRESSION__TARGET_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCastExpressionAccess().getCastExpressionBodyAction_1_0(), semanticObject.getBody());
		feeder.accept(grammarAccess.getCastExpressionAccess().getTargetTypeSymbolQualifiedNameParserRuleCall_1_2_0_1(), semanticObject.eGet(SolverLanguagePackage.Literals.CAST_EXPRESSION__TARGET_TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ClassDeclaration
	 *     ClassDeclaration returns ClassDeclaration
	 *
	 * Constraint:
	 *     ((abstract?='abstract' | root?='root')* name=ID (supertypes+=[Symbol|QualifiedName] supertypes+=[Symbol|QualifiedName]*)? fields+=Field*)
	 */
	protected void sequence_ClassDeclaration(ISerializationContext context, ClassDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssertionOrDefinition.Assertion_1_0_0 returns ConditionalExpression
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns ConditionalExpression
	 *     AssertionOrDefinition.FunctionDefinition_1_2_0 returns ConditionalExpression
	 *     Expression returns ConditionalExpression
	 *     Expression.Forall_2_1_0 returns ConditionalExpression
	 *     ConditionalExpression returns ConditionalExpression
	 *     DisjunctiveExpression returns ConditionalExpression
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns ConditionalExpression
	 *     DisjunctiveExpression.Case_1_1_0 returns ConditionalExpression
	 *     ConjunctiveExpression returns ConditionalExpression
	 *     ConjunctiveExpression.Conjunction_1_0 returns ConditionalExpression
	 *     ComparisonExpression returns ConditionalExpression
	 *     ComparisonExpression.BinaryExpression_1_0 returns ConditionalExpression
	 *     AdditiveExpression returns ConditionalExpression
	 *     AdditiveExpression.BinaryExpression_1_0 returns ConditionalExpression
	 *     MultiplicativeExpression returns ConditionalExpression
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns ConditionalExpression
	 *     ExponentialExpression returns ConditionalExpression
	 *     ExponentialExpression.BinaryExpression_1_0 returns ConditionalExpression
	 *     CastExpression returns ConditionalExpression
	 *     CastExpression.CastExpression_1_0 returns ConditionalExpression
	 *     UnaryExpression returns ConditionalExpression
	 *     BracedAggregateExpression returns ConditionalExpression
	 *     AtomicExpression returns ConditionalExpression
	 *
	 * Constraint:
	 *     (condition=DisjunctiveExpression then=Expression else=Expression)
	 */
	protected void sequence_ConditionalExpression(ISerializationContext context, ConditionalExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.CONDITIONAL_EXPRESSION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.CONDITIONAL_EXPRESSION__CONDITION));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.CONDITIONAL_EXPRESSION__THEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.CONDITIONAL_EXPRESSION__THEN));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.CONDITIONAL_EXPRESSION__ELSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.CONDITIONAL_EXPRESSION__ELSE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getConditionDisjunctiveExpressionParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getThenExpressionParserRuleCall_3_0(), semanticObject.getThen());
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getElseExpressionParserRuleCall_5_0(), semanticObject.getElse());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AssertionOrDefinition.Assertion_1_0_0 returns Conjunction
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns Conjunction
	 *     AssertionOrDefinition.FunctionDefinition_1_2_0 returns Conjunction
	 *     Expression returns Conjunction
	 *     Expression.Forall_2_1_0 returns Conjunction
	 *     DisjunctiveExpression returns Conjunction
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns Conjunction
	 *     DisjunctiveExpression.Case_1_1_0 returns Conjunction
	 *     ConjunctiveExpression returns Conjunction
	 *     ConjunctiveExpression.Conjunction_1_0 returns Conjunction
	 *     ComparisonExpression returns Conjunction
	 *     ComparisonExpression.BinaryExpression_1_0 returns Conjunction
	 *     AdditiveExpression returns Conjunction
	 *     AdditiveExpression.BinaryExpression_1_0 returns Conjunction
	 *     MultiplicativeExpression returns Conjunction
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns Conjunction
	 *     ExponentialExpression returns Conjunction
	 *     ExponentialExpression.BinaryExpression_1_0 returns Conjunction
	 *     CastExpression returns Conjunction
	 *     CastExpression.CastExpression_1_0 returns Conjunction
	 *     UnaryExpression returns Conjunction
	 *     BracedAggregateExpression returns Conjunction
	 *     AtomicExpression returns Conjunction
	 *
	 * Constraint:
	 *     (children+=ConjunctiveExpression_Conjunction_1_0 children+=ComparisonExpression+)
	 */
	protected void sequence_ConjunctiveExpression(ISerializationContext context, Conjunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssertionOrDefinition.Assertion_1_0_0 returns Count
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns Count
	 *     AssertionOrDefinition.FunctionDefinition_1_2_0 returns Count
	 *     Expression returns Count
	 *     Expression.Forall_2_1_0 returns Count
	 *     DisjunctiveExpression returns Count
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns Count
	 *     DisjunctiveExpression.Case_1_1_0 returns Count
	 *     ConjunctiveExpression returns Count
	 *     ConjunctiveExpression.Conjunction_1_0 returns Count
	 *     ComparisonExpression returns Count
	 *     ComparisonExpression.BinaryExpression_1_0 returns Count
	 *     AdditiveExpression returns Count
	 *     AdditiveExpression.BinaryExpression_1_0 returns Count
	 *     MultiplicativeExpression returns Count
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns Count
	 *     ExponentialExpression returns Count
	 *     ExponentialExpression.BinaryExpression_1_0 returns Count
	 *     CastExpression returns Count
	 *     CastExpression.CastExpression_1_0 returns Count
	 *     UnaryExpression returns Count
	 *     BracedAggregateExpression returns Count
	 *     Count returns Count
	 *     AtomicExpression returns Count
	 *
	 * Constraint:
	 *     condition=Expression
	 */
	protected void sequence_Count(ISerializationContext context, Count semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.AGGREGATE_EXPRESSION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.AGGREGATE_EXPRESSION__CONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCountAccess().getConditionExpressionParserRuleCall_2_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DefaultAssertion
	 *     DefaultAssertion returns DefaultAssertion
	 *
	 * Constraint:
	 *     (expression=Call range=Expression?)
	 */
	protected void sequence_DefaultAssertion(ISerializationContext context, DefaultAssertion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssertionOrDefinition.Assertion_1_0_0 returns Disjunction
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns Disjunction
	 *     AssertionOrDefinition.FunctionDefinition_1_2_0 returns Disjunction
	 *     Expression returns Disjunction
	 *     Expression.Forall_2_1_0 returns Disjunction
	 *     DisjunctiveExpression returns Disjunction
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns Disjunction
	 *     DisjunctiveExpression.Case_1_1_0 returns Disjunction
	 *     ConjunctiveExpression returns Disjunction
	 *     ConjunctiveExpression.Conjunction_1_0 returns Disjunction
	 *     ComparisonExpression returns Disjunction
	 *     ComparisonExpression.BinaryExpression_1_0 returns Disjunction
	 *     AdditiveExpression returns Disjunction
	 *     AdditiveExpression.BinaryExpression_1_0 returns Disjunction
	 *     MultiplicativeExpression returns Disjunction
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns Disjunction
	 *     ExponentialExpression returns Disjunction
	 *     ExponentialExpression.BinaryExpression_1_0 returns Disjunction
	 *     CastExpression returns Disjunction
	 *     CastExpression.CastExpression_1_0 returns Disjunction
	 *     UnaryExpression returns Disjunction
	 *     BracedAggregateExpression returns Disjunction
	 *     AtomicExpression returns Disjunction
	 *
	 * Constraint:
	 *     (children+=DisjunctiveExpression_Disjunction_1_0_0 children+=ConjunctiveExpression+)
	 */
	protected void sequence_DisjunctiveExpression(ISerializationContext context, Disjunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssertionOrDefinition.Assertion_1_0_0 returns Switch
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns Switch
	 *     AssertionOrDefinition.FunctionDefinition_1_2_0 returns Switch
	 *     Expression returns Switch
	 *     Expression.Forall_2_1_0 returns Switch
	 *     DisjunctiveExpression returns Switch
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns Switch
	 *     DisjunctiveExpression.Case_1_1_0 returns Switch
	 *     ConjunctiveExpression returns Switch
	 *     ConjunctiveExpression.Conjunction_1_0 returns Switch
	 *     ComparisonExpression returns Switch
	 *     ComparisonExpression.BinaryExpression_1_0 returns Switch
	 *     AdditiveExpression returns Switch
	 *     AdditiveExpression.BinaryExpression_1_0 returns Switch
	 *     MultiplicativeExpression returns Switch
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns Switch
	 *     ExponentialExpression returns Switch
	 *     ExponentialExpression.BinaryExpression_1_0 returns Switch
	 *     CastExpression returns Switch
	 *     CastExpression.CastExpression_1_0 returns Switch
	 *     UnaryExpression returns Switch
	 *     BracedAggregateExpression returns Switch
	 *     AtomicExpression returns Switch
	 *
	 * Constraint:
	 *     (cases+=DisjunctiveExpression_Switch_1_1_3 cases+=Case*)
	 */
	protected void sequence_DisjunctiveExpression(ISerializationContext context, Switch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DisjunctiveExpression.Switch_1_1_3 returns Case
	 *
	 * Constraint:
	 *     (condition=DisjunctiveExpression_Case_1_1_0 body=ConjunctiveExpression)
	 */
	protected void sequence_DisjunctiveExpression_Switch_1_1_3(ISerializationContext context, Case semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.CASE__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.CASE__CONDITION));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.CASE__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.CASE__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDisjunctiveExpressionAccess().getCaseConditionAction_1_1_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getDisjunctiveExpressionAccess().getBodyConjunctiveExpressionParserRuleCall_1_1_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AssertionOrDefinition.Assertion_1_0_0 returns EmptyLiteral
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns EmptyLiteral
	 *     AssertionOrDefinition.FunctionDefinition_1_2_0 returns EmptyLiteral
	 *     Expression returns EmptyLiteral
	 *     Expression.Forall_2_1_0 returns EmptyLiteral
	 *     DisjunctiveExpression returns EmptyLiteral
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns EmptyLiteral
	 *     DisjunctiveExpression.Case_1_1_0 returns EmptyLiteral
	 *     ConjunctiveExpression returns EmptyLiteral
	 *     ConjunctiveExpression.Conjunction_1_0 returns EmptyLiteral
	 *     ComparisonExpression returns EmptyLiteral
	 *     ComparisonExpression.BinaryExpression_1_0 returns EmptyLiteral
	 *     AdditiveExpression returns EmptyLiteral
	 *     AdditiveExpression.BinaryExpression_1_0 returns EmptyLiteral
	 *     MultiplicativeExpression returns EmptyLiteral
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns EmptyLiteral
	 *     ExponentialExpression returns EmptyLiteral
	 *     ExponentialExpression.BinaryExpression_1_0 returns EmptyLiteral
	 *     CastExpression returns EmptyLiteral
	 *     CastExpression.CastExpression_1_0 returns EmptyLiteral
	 *     UnaryExpression returns EmptyLiteral
	 *     BracedAggregateExpression returns EmptyLiteral
	 *     AtomicExpression returns EmptyLiteral
	 *     Literal returns EmptyLiteral
	 *     EmptyLiteral returns EmptyLiteral
	 *
	 * Constraint:
	 *     {EmptyLiteral}
	 */
	protected void sequence_EmptyLiteral(ISerializationContext context, EmptyLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns EnumDeclaration
	 *     EnumDeclaration returns EnumDeclaration
	 *
	 * Constraint:
	 *     (name=ID (literals+=EnumLiteral literals+=EnumLiteral*)?)
	 */
	protected void sequence_EnumDeclaration(ISerializationContext context, EnumDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumLiteral returns EnumLiteral
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_EnumLiteral(ISerializationContext context, EnumLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.ENUM_LITERAL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.ENUM_LITERAL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumLiteralAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Multiplicity returns ExactMultiplicity
	 *     ExactMultiplicity returns ExactMultiplicity
	 *
	 * Constraint:
	 *     value=UpperMultiplicty
	 */
	protected void sequence_ExactMultiplicity(ISerializationContext context, ExactMultiplicity semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.EXACT_MULTIPLICITY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.EXACT_MULTIPLICITY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExactMultiplicityAccess().getValueUpperMultiplictyParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ExactScope
	 *     ScopeDeclaration returns ExactScope
	 *     ExactScope returns ExactScope
	 *
	 * Constraint:
	 *     (type=[Symbol|QualifiedName] size=INT)
	 */
	protected void sequence_ExactScope(ISerializationContext context, ExactScope semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.SCOPE_DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.SCOPE_DECLARATION__TYPE));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.EXACT_SCOPE__SIZE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.EXACT_SCOPE__SIZE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExactScopeAccess().getTypeSymbolQualifiedNameParserRuleCall_1_0_1(), semanticObject.eGet(SolverLanguagePackage.Literals.SCOPE_DECLARATION__TYPE, false));
		feeder.accept(grammarAccess.getExactScopeAccess().getSizeINTTerminalRuleCall_3_0(), semanticObject.getSize());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Argument returns ExpressionArgument
	 *     ExpressionArgument returns ExpressionArgument
	 *
	 * Constraint:
	 *     expression=ComparisonExpression
	 */
	protected void sequence_ExpressionArgument(ISerializationContext context, ExpressionArgument semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.EXPRESSION_ARGUMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.EXPRESSION_ARGUMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionArgumentAccess().getExpressionComparisonExpressionParserRuleCall_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AssertionOrDefinition.Assertion_1_0_0 returns Forall
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns Forall
	 *     AssertionOrDefinition.FunctionDefinition_1_2_0 returns Forall
	 *     Expression returns Forall
	 *     Expression.Forall_2_1_0 returns Forall
	 *     DisjunctiveExpression returns Forall
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns Forall
	 *     DisjunctiveExpression.Case_1_1_0 returns Forall
	 *     ConjunctiveExpression returns Forall
	 *     ConjunctiveExpression.Conjunction_1_0 returns Forall
	 *     ComparisonExpression returns Forall
	 *     ComparisonExpression.BinaryExpression_1_0 returns Forall
	 *     AdditiveExpression returns Forall
	 *     AdditiveExpression.BinaryExpression_1_0 returns Forall
	 *     MultiplicativeExpression returns Forall
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns Forall
	 *     ExponentialExpression returns Forall
	 *     ExponentialExpression.BinaryExpression_1_0 returns Forall
	 *     CastExpression returns Forall
	 *     CastExpression.CastExpression_1_0 returns Forall
	 *     UnaryExpression returns Forall
	 *     BracedAggregateExpression returns Forall
	 *     AtomicExpression returns Forall
	 *
	 * Constraint:
	 *     (condition=Expression_Forall_2_1_0 body=DisjunctiveExpression)
	 */
	protected void sequence_Expression(ISerializationContext context, Forall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.AGGREGATE_EXPRESSION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.AGGREGATE_EXPRESSION__CONDITION));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.FORALL__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.FORALL__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getForallConditionAction_2_1_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getExpressionAccess().getBodyDisjunctiveExpressionParserRuleCall_2_1_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ExternAggregationOperatorDeclaration
	 *     ExternDeclaration returns ExternAggregationOperatorDeclaration
	 *     ExternAggregationOperatorDeclaration returns ExternAggregationOperatorDeclaration
	 *
	 * Constraint:
	 *     (resultType=[Symbol|QualifiedName] name=QualifiedName argumentType=[Symbol|QualifiedName])
	 */
	protected void sequence_ExternAggregationOperatorDeclaration(ISerializationContext context, ExternAggregationOperatorDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.EXTERN_AGGREGATION_OPERATOR_DECLARATION__RESULT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.EXTERN_AGGREGATION_OPERATOR_DECLARATION__RESULT_TYPE));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.EXTERN_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.EXTERN_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.EXTERN_AGGREGATION_OPERATOR_DECLARATION__ARGUMENT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.EXTERN_AGGREGATION_OPERATOR_DECLARATION__ARGUMENT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExternAggregationOperatorDeclarationAccess().getResultTypeSymbolQualifiedNameParserRuleCall_1_0_1(), semanticObject.eGet(SolverLanguagePackage.Literals.EXTERN_AGGREGATION_OPERATOR_DECLARATION__RESULT_TYPE, false));
		feeder.accept(grammarAccess.getExternAggregationOperatorDeclarationAccess().getNameQualifiedNameParserRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getExternAggregationOperatorDeclarationAccess().getArgumentTypeSymbolQualifiedNameParserRuleCall_4_0_1(), semanticObject.eGet(SolverLanguagePackage.Literals.EXTERN_AGGREGATION_OPERATOR_DECLARATION__ARGUMENT_TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ExternDatatypeDeclaration
	 *     ExternDeclaration returns ExternDatatypeDeclaration
	 *     ExternDatatypeDeclaration returns ExternDatatypeDeclaration
	 *
	 * Constraint:
	 *     name=QualifiedName
	 */
	protected void sequence_ExternDatatypeDeclaration(ISerializationContext context, ExternDatatypeDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.EXTERN_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.EXTERN_DECLARATION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExternDatatypeDeclarationAccess().getNameQualifiedNameParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ExternFunctionDeclaration
	 *     ExternDeclaration returns ExternFunctionDeclaration
	 *     ExternFunctionDeclaration returns ExternFunctionDeclaration
	 *
	 * Constraint:
	 *     (resultType=[Symbol|QualifiedName] name=QualifiedName argumentList=ArgumentList)
	 */
	protected void sequence_ExternFunctionDeclaration(ISerializationContext context, ExternFunctionDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.EXTERN_FUNCTION_DECLARATION__RESULT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.EXTERN_FUNCTION_DECLARATION__RESULT_TYPE));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.EXTERN_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.EXTERN_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.EXTERN_FUNCTOR_DECLARATION__ARGUMENT_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.EXTERN_FUNCTOR_DECLARATION__ARGUMENT_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExternFunctionDeclarationAccess().getResultTypeSymbolQualifiedNameParserRuleCall_1_0_1(), semanticObject.eGet(SolverLanguagePackage.Literals.EXTERN_FUNCTION_DECLARATION__RESULT_TYPE, false));
		feeder.accept(grammarAccess.getExternFunctionDeclarationAccess().getNameQualifiedNameParserRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getExternFunctionDeclarationAccess().getArgumentListArgumentListParserRuleCall_3_0(), semanticObject.getArgumentList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ExternPredicateDeclaration
	 *     ExternDeclaration returns ExternPredicateDeclaration
	 *     ExternPredicateDeclaration returns ExternPredicateDeclaration
	 *
	 * Constraint:
	 *     ((functional?='functional' | error?='error')* name=QualifiedName argumentList=ArgumentList)
	 */
	protected void sequence_ExternPredicateDeclaration(ISerializationContext context, ExternPredicateDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Field returns Field
	 *
	 * Constraint:
	 *     (
	 *         (containment?='contains' | crossReference?='refers')? 
	 *         type=[Symbol|QualifiedName] 
	 *         multiplicity=Multiplicity? 
	 *         name=ID 
	 *         opposite=[Symbol|QualifiedName]?
	 *     )
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionDefinition returns FunctionDefinition
	 *
	 * Constraint:
	 *     (resultType=[Symbol|QualifiedName] head=Call body=Expression)
	 */
	protected void sequence_FunctionDefinition(ISerializationContext context, FunctionDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.FUNCTION_DEFINITION__RESULT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.FUNCTION_DEFINITION__RESULT_TYPE));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.FUNCTOR_DEFINITON__HEAD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.FUNCTOR_DEFINITON__HEAD));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.FUNCTOR_DEFINITON__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.FUNCTOR_DEFINITON__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionDefinitionAccess().getResultTypeSymbolQualifiedNameParserRuleCall_0_0_1(), semanticObject.eGet(SolverLanguagePackage.Literals.FUNCTION_DEFINITION__RESULT_TYPE, false));
		feeder.accept(grammarAccess.getFunctionDefinitionAccess().getHeadCallParserRuleCall_1_0(), semanticObject.getHead());
		feeder.accept(grammarAccess.getFunctionDefinitionAccess().getBodyExpressionParserRuleCall_3_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AssertionOrDefinition.Assertion_1_0_0 returns InfinityLiteral
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns InfinityLiteral
	 *     AssertionOrDefinition.FunctionDefinition_1_2_0 returns InfinityLiteral
	 *     Expression returns InfinityLiteral
	 *     Expression.Forall_2_1_0 returns InfinityLiteral
	 *     DisjunctiveExpression returns InfinityLiteral
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns InfinityLiteral
	 *     DisjunctiveExpression.Case_1_1_0 returns InfinityLiteral
	 *     ConjunctiveExpression returns InfinityLiteral
	 *     ConjunctiveExpression.Conjunction_1_0 returns InfinityLiteral
	 *     ComparisonExpression returns InfinityLiteral
	 *     ComparisonExpression.BinaryExpression_1_0 returns InfinityLiteral
	 *     AdditiveExpression returns InfinityLiteral
	 *     AdditiveExpression.BinaryExpression_1_0 returns InfinityLiteral
	 *     MultiplicativeExpression returns InfinityLiteral
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns InfinityLiteral
	 *     ExponentialExpression returns InfinityLiteral
	 *     ExponentialExpression.BinaryExpression_1_0 returns InfinityLiteral
	 *     CastExpression returns InfinityLiteral
	 *     CastExpression.CastExpression_1_0 returns InfinityLiteral
	 *     UnaryExpression returns InfinityLiteral
	 *     BracedAggregateExpression returns InfinityLiteral
	 *     AtomicExpression returns InfinityLiteral
	 *     Literal returns InfinityLiteral
	 *     InfinityLiteral returns InfinityLiteral
	 *
	 * Constraint:
	 *     {InfinityLiteral}
	 */
	protected void sequence_InfinityLiteral(ISerializationContext context, InfinityLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssertionOrDefinition.Assertion_1_0_0 returns IntLiteral
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns IntLiteral
	 *     AssertionOrDefinition.FunctionDefinition_1_2_0 returns IntLiteral
	 *     Expression returns IntLiteral
	 *     Expression.Forall_2_1_0 returns IntLiteral
	 *     DisjunctiveExpression returns IntLiteral
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns IntLiteral
	 *     DisjunctiveExpression.Case_1_1_0 returns IntLiteral
	 *     ConjunctiveExpression returns IntLiteral
	 *     ConjunctiveExpression.Conjunction_1_0 returns IntLiteral
	 *     ComparisonExpression returns IntLiteral
	 *     ComparisonExpression.BinaryExpression_1_0 returns IntLiteral
	 *     AdditiveExpression returns IntLiteral
	 *     AdditiveExpression.BinaryExpression_1_0 returns IntLiteral
	 *     MultiplicativeExpression returns IntLiteral
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns IntLiteral
	 *     ExponentialExpression returns IntLiteral
	 *     ExponentialExpression.BinaryExpression_1_0 returns IntLiteral
	 *     CastExpression returns IntLiteral
	 *     CastExpression.CastExpression_1_0 returns IntLiteral
	 *     UnaryExpression returns IntLiteral
	 *     BracedAggregateExpression returns IntLiteral
	 *     AtomicExpression returns IntLiteral
	 *     Literal returns IntLiteral
	 *     IntLiteral returns IntLiteral
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_IntLiteral(ISerializationContext context, IntLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.INT_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.INT_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntLiteralAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AssertionOrDefinition.Assertion_1_0_0 returns Interval
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns Interval
	 *     AssertionOrDefinition.FunctionDefinition_1_2_0 returns Interval
	 *     Expression returns Interval
	 *     Expression.Forall_2_1_0 returns Interval
	 *     DisjunctiveExpression returns Interval
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns Interval
	 *     DisjunctiveExpression.Case_1_1_0 returns Interval
	 *     ConjunctiveExpression returns Interval
	 *     ConjunctiveExpression.Conjunction_1_0 returns Interval
	 *     ComparisonExpression returns Interval
	 *     ComparisonExpression.BinaryExpression_1_0 returns Interval
	 *     AdditiveExpression returns Interval
	 *     AdditiveExpression.BinaryExpression_1_0 returns Interval
	 *     MultiplicativeExpression returns Interval
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns Interval
	 *     ExponentialExpression returns Interval
	 *     ExponentialExpression.BinaryExpression_1_0 returns Interval
	 *     CastExpression returns Interval
	 *     CastExpression.CastExpression_1_0 returns Interval
	 *     UnaryExpression returns Interval
	 *     BracedAggregateExpression returns Interval
	 *     AtomicExpression returns Interval
	 *     Interval returns Interval
	 *
	 * Constraint:
	 *     (lowerBound=AdditiveExpression upperBound=AdditiveExpression)
	 */
	protected void sequence_Interval(ISerializationContext context, Interval semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.INTERVAL__LOWER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.INTERVAL__LOWER_BOUND));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.INTERVAL__UPPER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.INTERVAL__UPPER_BOUND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntervalAccess().getLowerBoundAdditiveExpressionParserRuleCall_1_0(), semanticObject.getLowerBound());
		feeder.accept(grammarAccess.getIntervalAccess().getUpperBoundAdditiveExpressionParserRuleCall_3_0(), semanticObject.getUpperBound());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LetBinding returns LetBinding
	 *
	 * Constraint:
	 *     (type=[Symbol|QualifiedName]? name=ID value=AdditiveExpression)
	 */
	protected void sequence_LetBinding(ISerializationContext context, LetBinding semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssertionOrDefinition.Assertion_1_0_0 returns LetExpression
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns LetExpression
	 *     AssertionOrDefinition.FunctionDefinition_1_2_0 returns LetExpression
	 *     Expression returns LetExpression
	 *     Expression.Forall_2_1_0 returns LetExpression
	 *     LetExpression returns LetExpression
	 *     DisjunctiveExpression returns LetExpression
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns LetExpression
	 *     DisjunctiveExpression.Case_1_1_0 returns LetExpression
	 *     ConjunctiveExpression returns LetExpression
	 *     ConjunctiveExpression.Conjunction_1_0 returns LetExpression
	 *     ComparisonExpression returns LetExpression
	 *     ComparisonExpression.BinaryExpression_1_0 returns LetExpression
	 *     AdditiveExpression returns LetExpression
	 *     AdditiveExpression.BinaryExpression_1_0 returns LetExpression
	 *     MultiplicativeExpression returns LetExpression
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns LetExpression
	 *     ExponentialExpression returns LetExpression
	 *     ExponentialExpression.BinaryExpression_1_0 returns LetExpression
	 *     CastExpression returns LetExpression
	 *     CastExpression.CastExpression_1_0 returns LetExpression
	 *     UnaryExpression returns LetExpression
	 *     BracedAggregateExpression returns LetExpression
	 *     AtomicExpression returns LetExpression
	 *
	 * Constraint:
	 *     (bindings+=LetBinding bindings+=LetBinding* body=Expression)
	 */
	protected void sequence_LetExpression(ISerializationContext context, LetExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssertionOrDefinition.Assertion_1_0_0 returns LogicLiteral
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns LogicLiteral
	 *     AssertionOrDefinition.FunctionDefinition_1_2_0 returns LogicLiteral
	 *     Expression returns LogicLiteral
	 *     Expression.Forall_2_1_0 returns LogicLiteral
	 *     DisjunctiveExpression returns LogicLiteral
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns LogicLiteral
	 *     DisjunctiveExpression.Case_1_1_0 returns LogicLiteral
	 *     ConjunctiveExpression returns LogicLiteral
	 *     ConjunctiveExpression.Conjunction_1_0 returns LogicLiteral
	 *     ComparisonExpression returns LogicLiteral
	 *     ComparisonExpression.BinaryExpression_1_0 returns LogicLiteral
	 *     AdditiveExpression returns LogicLiteral
	 *     AdditiveExpression.BinaryExpression_1_0 returns LogicLiteral
	 *     MultiplicativeExpression returns LogicLiteral
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns LogicLiteral
	 *     ExponentialExpression returns LogicLiteral
	 *     ExponentialExpression.BinaryExpression_1_0 returns LogicLiteral
	 *     CastExpression returns LogicLiteral
	 *     CastExpression.CastExpression_1_0 returns LogicLiteral
	 *     UnaryExpression returns LogicLiteral
	 *     BracedAggregateExpression returns LogicLiteral
	 *     AtomicExpression returns LogicLiteral
	 *     Literal returns LogicLiteral
	 *     LogicLiteral returns LogicLiteral
	 *
	 * Constraint:
	 *     value=LogicValue
	 */
	protected void sequence_LogicLiteral(ISerializationContext context, LogicLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.LOGIC_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.LOGIC_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicLiteralAccess().getValueLogicValueEnumRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns LowerBoundedScope
	 *     ScopeDeclaration returns LowerBoundedScope
	 *     LowerBoundedScope returns LowerBoundedScope
	 *
	 * Constraint:
	 *     ((lowerBound=INT type=[Symbol|QualifiedName]) | (type=[Symbol|QualifiedName] lowerBound=INT))
	 */
	protected void sequence_LowerBoundedScope(ISerializationContext context, LowerBoundedScope semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns NamespaceImport
	 *     NamespaceImport returns NamespaceImport
	 *
	 * Constraint:
	 *     (importedNamespace=QualifiedName alias=QualifiedName)
	 */
	protected void sequence_NamespaceImport(ISerializationContext context, NamespaceImport semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.NAMESPACE_IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.NAMESPACE_IMPORT__IMPORTED_NAMESPACE));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.IMPORT__ALIAS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.IMPORT__ALIAS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNamespaceImportAccess().getImportedNamespaceQualifiedNameParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.accept(grammarAccess.getNamespaceImportAccess().getAliasQualifiedNameParserRuleCall_2_1_0(), semanticObject.getAlias());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ObjectiveDeclaration
	 *     ObjectiveDeclaration returns ObjectiveDeclaration
	 *
	 * Constraint:
	 *     (kind=ObjectiveKind objective=Expression)
	 */
	protected void sequence_ObjectiveDeclaration(ISerializationContext context, ObjectiveDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.OBJECTIVE_DECLARATION__KIND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.OBJECTIVE_DECLARATION__KIND));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.OBJECTIVE_DECLARATION__OBJECTIVE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.OBJECTIVE_DECLARATION__OBJECTIVE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjectiveDeclarationAccess().getKindObjectiveKindEnumRuleCall_0_0(), semanticObject.getKind());
		feeder.accept(grammarAccess.getObjectiveDeclarationAccess().getObjectiveExpressionParserRuleCall_1_0(), semanticObject.getObjective());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PathComponent returns PathComponent
	 *
	 * Constraint:
	 *     (
	 *         inverse?='~'? 
	 *         symbol=[Symbol|QualifiedName] 
	 *         (transitiveClosure?=TRANSITIVE_CLOSURE | reflexiveTransitiveClosure?=REFLEXIVE_TRANSITIVE_CLOSURE)?
	 *     )
	 */
	protected void sequence_PathComponent(ISerializationContext context, PathComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PredicateDefinition returns PredicateDefinition
	 *
	 * Constraint:
	 *     (((functional?='functional' error?='error'?) | (error?='error' functional?='functional'?)) head=Call body=Expression)
	 */
	protected void sequence_PredicateDefinition(ISerializationContext context, PredicateDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Problem returns Problem
	 *
	 * Constraint:
	 *     ((name=QualifiedName? imports+=Import+ statements+=Statement+) | (name=QualifiedName? statements+=Statement+) | statements+=Statement+)?
	 */
	protected void sequence_Problem(ISerializationContext context, Problem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssertionOrDefinition.Assertion_1_0_0 returns RealLiteral
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns RealLiteral
	 *     AssertionOrDefinition.FunctionDefinition_1_2_0 returns RealLiteral
	 *     Expression returns RealLiteral
	 *     Expression.Forall_2_1_0 returns RealLiteral
	 *     DisjunctiveExpression returns RealLiteral
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns RealLiteral
	 *     DisjunctiveExpression.Case_1_1_0 returns RealLiteral
	 *     ConjunctiveExpression returns RealLiteral
	 *     ConjunctiveExpression.Conjunction_1_0 returns RealLiteral
	 *     ComparisonExpression returns RealLiteral
	 *     ComparisonExpression.BinaryExpression_1_0 returns RealLiteral
	 *     AdditiveExpression returns RealLiteral
	 *     AdditiveExpression.BinaryExpression_1_0 returns RealLiteral
	 *     MultiplicativeExpression returns RealLiteral
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns RealLiteral
	 *     ExponentialExpression returns RealLiteral
	 *     ExponentialExpression.BinaryExpression_1_0 returns RealLiteral
	 *     CastExpression returns RealLiteral
	 *     CastExpression.CastExpression_1_0 returns RealLiteral
	 *     UnaryExpression returns RealLiteral
	 *     BracedAggregateExpression returns RealLiteral
	 *     AtomicExpression returns RealLiteral
	 *     Literal returns RealLiteral
	 *     RealLiteral returns RealLiteral
	 *
	 * Constraint:
	 *     value=Real
	 */
	protected void sequence_RealLiteral(ISerializationContext context, RealLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.REAL_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.REAL_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRealLiteralAccess().getValueRealParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AssertionOrDefinition.Assertion_1_0_0 returns Reference
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns Reference
	 *     AssertionOrDefinition.FunctionDefinition_1_2_0 returns Reference
	 *     Expression returns Reference
	 *     Expression.Forall_2_1_0 returns Reference
	 *     DisjunctiveExpression returns Reference
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns Reference
	 *     DisjunctiveExpression.Case_1_1_0 returns Reference
	 *     ConjunctiveExpression returns Reference
	 *     ConjunctiveExpression.Conjunction_1_0 returns Reference
	 *     ComparisonExpression returns Reference
	 *     ComparisonExpression.BinaryExpression_1_0 returns Reference
	 *     AdditiveExpression returns Reference
	 *     AdditiveExpression.BinaryExpression_1_0 returns Reference
	 *     MultiplicativeExpression returns Reference
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns Reference
	 *     ExponentialExpression returns Reference
	 *     ExponentialExpression.BinaryExpression_1_0 returns Reference
	 *     CastExpression returns Reference
	 *     CastExpression.CastExpression_1_0 returns Reference
	 *     UnaryExpression returns Reference
	 *     BracedAggregateExpression returns Reference
	 *     AtomicExpression returns Reference
	 *     Reference returns Reference
	 *
	 * Constraint:
	 *     (components+=PathComponent components+=PathComponent*)
	 */
	protected void sequence_Reference(ISerializationContext context, Reference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Argument returns StarArgument
	 *     StarArgument returns StarArgument
	 *
	 * Constraint:
	 *     {StarArgument}
	 */
	protected void sequence_StarArgument(ISerializationContext context, StarArgument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssertionOrDefinition.Assertion_1_0_0 returns StringLiteral
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns StringLiteral
	 *     AssertionOrDefinition.FunctionDefinition_1_2_0 returns StringLiteral
	 *     Expression returns StringLiteral
	 *     Expression.Forall_2_1_0 returns StringLiteral
	 *     DisjunctiveExpression returns StringLiteral
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns StringLiteral
	 *     DisjunctiveExpression.Case_1_1_0 returns StringLiteral
	 *     ConjunctiveExpression returns StringLiteral
	 *     ConjunctiveExpression.Conjunction_1_0 returns StringLiteral
	 *     ComparisonExpression returns StringLiteral
	 *     ComparisonExpression.BinaryExpression_1_0 returns StringLiteral
	 *     AdditiveExpression returns StringLiteral
	 *     AdditiveExpression.BinaryExpression_1_0 returns StringLiteral
	 *     MultiplicativeExpression returns StringLiteral
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns StringLiteral
	 *     ExponentialExpression returns StringLiteral
	 *     ExponentialExpression.BinaryExpression_1_0 returns StringLiteral
	 *     CastExpression returns StringLiteral
	 *     CastExpression.CastExpression_1_0 returns StringLiteral
	 *     UnaryExpression returns StringLiteral
	 *     BracedAggregateExpression returns StringLiteral
	 *     AtomicExpression returns StringLiteral
	 *     Literal returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeReference returns TypeReference
	 *
	 * Constraint:
	 *     (type=[Symbol|QualifiedName] forceObjectType?='object'?)
	 */
	protected void sequence_TypeReference(ISerializationContext context, TypeReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Argument returns TypedStarArgument
	 *     TypedStarArgument returns TypedStarArgument
	 *
	 * Constraint:
	 *     typeReference=TypeReference
	 */
	protected void sequence_TypedStarArgument(ISerializationContext context, TypedStarArgument semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.TYPED_ARGUMENT__TYPE_REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.TYPED_ARGUMENT__TYPE_REFERENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypedStarArgumentAccess().getTypeReferenceTypeReferenceParserRuleCall_0_0(), semanticObject.getTypeReference());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Argument returns TypedVariableArgument
	 *     TypedVariableArgument returns TypedVariableArgument
	 *
	 * Constraint:
	 *     (typeReference=TypeReference name=ID)
	 */
	protected void sequence_TypedVariableArgument(ISerializationContext context, TypedVariableArgument semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.TYPED_ARGUMENT__TYPE_REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.TYPED_ARGUMENT__TYPE_REFERENCE));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.TYPED_VARIABLE_ARGUMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.TYPED_VARIABLE_ARGUMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypedVariableArgumentAccess().getTypeReferenceTypeReferenceParserRuleCall_0_0(), semanticObject.getTypeReference());
		feeder.accept(grammarAccess.getTypedVariableArgumentAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AssertionOrDefinition.Assertion_1_0_0 returns UnaryExpression
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns UnaryExpression
	 *     AssertionOrDefinition.FunctionDefinition_1_2_0 returns UnaryExpression
	 *     Expression returns UnaryExpression
	 *     Expression.Forall_2_1_0 returns UnaryExpression
	 *     DisjunctiveExpression returns UnaryExpression
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns UnaryExpression
	 *     DisjunctiveExpression.Case_1_1_0 returns UnaryExpression
	 *     ConjunctiveExpression returns UnaryExpression
	 *     ConjunctiveExpression.Conjunction_1_0 returns UnaryExpression
	 *     ComparisonExpression returns UnaryExpression
	 *     ComparisonExpression.BinaryExpression_1_0 returns UnaryExpression
	 *     AdditiveExpression returns UnaryExpression
	 *     AdditiveExpression.BinaryExpression_1_0 returns UnaryExpression
	 *     MultiplicativeExpression returns UnaryExpression
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns UnaryExpression
	 *     ExponentialExpression returns UnaryExpression
	 *     ExponentialExpression.BinaryExpression_1_0 returns UnaryExpression
	 *     CastExpression returns UnaryExpression
	 *     CastExpression.CastExpression_1_0 returns UnaryExpression
	 *     UnaryExpression returns UnaryExpression
	 *     BracedAggregateExpression returns UnaryExpression
	 *     AtomicExpression returns UnaryExpression
	 *
	 * Constraint:
	 *     (op=UnaryOperator body=BracedAggregateExpression)
	 */
	protected void sequence_UnaryExpression(ISerializationContext context, UnaryExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.UNARY_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.UNARY_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.UNARY_EXPRESSION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.UNARY_EXPRESSION__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getOpUnaryOperatorEnumRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getBodyBracedAggregateExpressionParserRuleCall_1_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Multiplicity returns UnboundedMultiplicity
	 *     UnboundedMultiplicity returns UnboundedMultiplicity
	 *
	 * Constraint:
	 *     {UnboundedMultiplicity}
	 */
	protected void sequence_UnboundedMultiplicity(ISerializationContext context, UnboundedMultiplicity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns UnnamedErrorPredicateDefintion
	 *     UnnamedErrorPredicateDefintion returns UnnamedErrorPredicateDefintion
	 *
	 * Constraint:
	 *     (argumentList=ArgumentList body=Expression)
	 */
	protected void sequence_UnnamedErrorPredicateDefintion(ISerializationContext context, UnnamedErrorPredicateDefintion semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.UNNAMED_ERROR_PREDICATE_DEFINTION__ARGUMENT_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.UNNAMED_ERROR_PREDICATE_DEFINTION__ARGUMENT_LIST));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.UNNAMED_ERROR_PREDICATE_DEFINTION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.UNNAMED_ERROR_PREDICATE_DEFINTION__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnnamedErrorPredicateDefintionAccess().getArgumentListArgumentListParserRuleCall_1_0(), semanticObject.getArgumentList());
		feeder.accept(grammarAccess.getUnnamedErrorPredicateDefintionAccess().getBodyExpressionParserRuleCall_3_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Import returns UriImport
	 *     UriImport returns UriImport
	 *
	 * Constraint:
	 *     (uri=STRING alias=QualifiedName)
	 */
	protected void sequence_UriImport(ISerializationContext context, UriImport semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.URI_IMPORT__URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.URI_IMPORT__URI));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.IMPORT__ALIAS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.IMPORT__ALIAS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUriImportAccess().getUriSTRINGTerminalRuleCall_1_0(), semanticObject.getUri());
		feeder.accept(grammarAccess.getUriImportAccess().getAliasQualifiedNameParserRuleCall_2_1_0(), semanticObject.getAlias());
		feeder.finish();
	}
	
	
}
