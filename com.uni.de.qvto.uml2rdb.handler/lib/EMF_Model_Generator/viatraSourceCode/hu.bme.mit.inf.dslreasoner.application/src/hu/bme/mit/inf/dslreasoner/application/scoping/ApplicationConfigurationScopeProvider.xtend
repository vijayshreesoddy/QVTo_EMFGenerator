/*
 * generated by Xtext 2.10.0
 */
package hu.bme.mit.inf.dslreasoner.application.scoping

import com.google.inject.Inject
import hu.bme.mit.inf.dslreasoner.application.applicationConfiguration.ConfigurationScript
import hu.bme.mit.inf.dslreasoner.application.applicationConfiguration.EPackageImport
import hu.bme.mit.inf.dslreasoner.application.applicationConfiguration.MetamodelElement
import hu.bme.mit.inf.dslreasoner.application.applicationConfiguration.MetamodelEntry
import hu.bme.mit.inf.dslreasoner.application.applicationConfiguration.PatternEntry
import hu.bme.mit.inf.dslreasoner.application.applicationConfiguration.ViatraImport
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EEnum
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.viatra.query.patternlanguage.emf.vql.PatternModel
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.naming.IQualifiedNameConverter
import org.eclipse.xtext.scoping.Scopes

import static hu.bme.mit.inf.dslreasoner.application.applicationConfiguration.ApplicationConfigurationPackage.Literals.*

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class ApplicationConfigurationScopeProvider extends AbstractApplicationConfigurationScopeProvider {

	@Inject IQualifiedNameConverter qualifiedNameConverter

	override getScope(EObject context, EReference reference) {
		val document = EcoreUtil2.getContainerOfType(context, ConfigurationScript)
		switch (reference) {
			case METAMODEL_ENTRY__PACKAGE:
				getEPackageScope(document)
			case METAMODEL_ELEMENT__CLASSIFIER:
				getEClassifierScope(context, document)
			case METAMODEL_ELEMENT__FEATURE:
				getEStructuralFeatureScope(context, reference, document)
			case PATTERN_ENTRY__PACKAGE:
				getViatraPackageScope(context, reference, document)
			case PATTERN_ELEMENT__PATTERN:
				getViatraPatternScope(context, document)
			default:
				super.getScope(context, reference)
		}
	}

	private def getAllEPackages(ConfigurationScript document) {
		document.imports.filter(EPackageImport).map[importedPackage].filterNull
	}

	private def getAllViatraPackages(ConfigurationScript document) {
		document.imports.filter(ViatraImport).map[importedViatra].filterNull
	}

	private def getAllEClassifiers(ConfigurationScript document) {
		document.allEPackages.map[EClassifiers].flatten
	}

	private def getAllPatterns(ConfigurationScript document) {
		document.allViatraPackages.map[patterns].flatten
	}

	private def getEPackageScope(ConfigurationScript document) {
		Scopes.scopeFor(document.allEPackages)
	}

	private def getEClassifierScope(EObject context, ConfigurationScript document) {
		val classifiers = switch (context) {
			MetamodelEntry case context.package !== null:
				context.package.EClassifiers
			default:
				document.allEClassifiers
		}
		Scopes.scopeFor(classifiers)
	}

	private def getEStructuralFeatureScope(EObject context, EReference reference, ConfigurationScript document) {
		val referredClassifier = if (context instanceof MetamodelElement) {
				context.classifier
			} else {
				null
			}
		switch (referredClassifier) {
			EClass:
				Scopes.scopeFor(referredClassifier.EAllStructuralFeatures)
			EEnum:
				Scopes.scopeFor(referredClassifier.ELiterals)
			default:
				super.getScope(context, reference)
		}
	}

	private def getViatraPackageScope(EObject context, EReference reference, ConfigurationScript document) {
		val patternModelNameConverter = [ PatternModel patternModel |
			toQualifiedNameOrNull(patternModel.packageName)
		]
		Scopes.scopeFor(document.allViatraPackages, patternModelNameConverter, super.getScope(context, reference))
	}

	private def getViatraPatternScope(EObject context, ConfigurationScript document) {
		val patterns = switch (context) {
			PatternEntry case context.package !== null:
				context.package.patterns
			default:
				document.allPatterns
		}
		Scopes.scopeFor(patterns)
	}
	
	private def toQualifiedNameOrNull(String packageName) {
		if (packageName === null) {
			null
		} else {
			qualifiedNameConverter.toQualifiedName(packageName)
		}	
	}
}
