/*
 * generated by Xtext 2.21.0
 */
package org.eclipse.viatra.solver.language.parser.antlr;

import static org.eclipse.viatra.solver.language.parser.antlr.internal.InternalSolverLanguageParser.RULE_FULL_STOP;
import static org.eclipse.viatra.solver.language.parser.antlr.internal.InternalSolverLanguageParser.RULE_ID;
import static org.eclipse.viatra.solver.language.parser.antlr.internal.InternalSolverLanguageParser.RULE_INT;
import static org.eclipse.viatra.solver.language.parser.antlr.internal.InternalSolverLanguageParser.RULE_ML_COMMENT;
import static org.eclipse.viatra.solver.language.parser.antlr.internal.InternalSolverLanguageParser.RULE_QUOTED_ID;
import static org.eclipse.viatra.solver.language.parser.antlr.internal.InternalSolverLanguageParser.RULE_REFLEXIVE_TRANSITIVE_CLOSURE;
import static org.eclipse.viatra.solver.language.parser.antlr.internal.InternalSolverLanguageParser.RULE_SL_COMMENT;
import static org.eclipse.viatra.solver.language.parser.antlr.internal.InternalSolverLanguageParser.RULE_TRANSITIVE_CLOSURE;
import static org.eclipse.viatra.solver.language.parser.antlr.internal.InternalSolverLanguageParser.RULE_WS;

import java.util.Map;

import org.antlr.runtime.Token;
import org.antlr.runtime.TokenSource;
import org.eclipse.xtext.parser.antlr.ITokenDefProvider;
import org.eclipse.xtext.parser.antlr.TokenAcceptor;

public class SolverLanguageTokenSource implements TokenSource {
	private TokenSource delegate;

	private final TokenAcceptor acceptor = new TokenAcceptor();

	private int lastTokenId = -1;
	private int plusTokenId = -1;
	private int starTokenId = -1;
	private int dotTokenId = -1;
	private int tildeTokenId = -1;
	private int openParenTokenId = -1;

	public SolverLanguageTokenSource(TokenSource delegate) {
		this.delegate = delegate;
	}

	@Override
	public String getSourceName() {
		return "[SolverLanguageSyntheticTokenTokenSource] " + delegate.getSourceName();
	}

	@Override
	public Token nextToken() {
		Token token;
		if (acceptor.hasNext()) {
			token = acceptor.next();
		} else {
			token = delegate.nextToken();
		}
		postProcessToken(token);
		lastTokenId = token.getType();
		return token;
	}

	protected void postProcessToken(Token token) {
		int type = token.getType();
		if (type == plusTokenId) {
			if (isTransitiveClosureInReferenceContext()) {
				token.setType(RULE_TRANSITIVE_CLOSURE);
			}
		} else if (type == starTokenId) {
			if (isTransitiveClosureInReferenceContext()) {
				token.setType(RULE_REFLEXIVE_TRANSITIVE_CLOSURE);
			}
		} else if (type == dotTokenId) {
			if (isFullStopContext()) {
				token.setType(RULE_FULL_STOP);
			}
		}
	}

	private boolean isIdFragment(int tokenId) {
		return tokenId == RULE_ID || tokenId == RULE_QUOTED_ID;
	}

	private boolean isTransitiveClosureInReferenceContext() {
		int nextVisibleTokenId = peekUntilVisible().getType();
		return isIdFragment(lastTokenId)
				&& (nextVisibleTokenId == dotTokenId || nextVisibleTokenId == openParenTokenId);
	}

	private boolean isFullStopContext() {
		int nextTokenId = peekToken().getType();
		boolean inReference = isIdFragment(lastTokenId) && (isIdFragment(nextTokenId) || nextTokenId == tildeTokenId);
		boolean inReal = lastTokenId == RULE_INT && nextTokenId == RULE_INT;
		return !(inReference || inReal);
	}

	protected Token peekUntilVisible() {
		Token followingToken = null;
		do {
			followingToken = peekToken();
		} while (isHidden(followingToken.getType()));
		return followingToken;
	}

	protected Token peekToken() {
		Token followingToken = delegate.nextToken();
		acceptor.accept(followingToken);
		return followingToken;
	}

	protected boolean isHidden(int tokenType) {
		return tokenType == RULE_WS || tokenType == RULE_SL_COMMENT || tokenType == RULE_ML_COMMENT;
	}

	public void initializeTokenDefsFrom(ITokenDefProvider provider) {
		for (Map.Entry<Integer, String> entry : provider.getTokenDefMap().entrySet()) {
			switch (entry.getValue()) {
			case "'+'":
				plusTokenId = entry.getKey();
				break;
			case "'*'":
				starTokenId = entry.getKey();
				break;
			case "'.'":
				dotTokenId = entry.getKey();
				break;
			case "'~'":
				tildeTokenId = entry.getKey();
				break;
			case "'('":
				openParenTokenId = entry.getKey();
				break;
			}
		}
		if (plusTokenId == -1) {
			throw new IllegalStateException("Token '+' was not found");
		}
		if (starTokenId == -1) {
			throw new IllegalStateException("Token '*' was not found");
		}
		if (dotTokenId == -1) {
			throw new IllegalStateException("Token '.' was not found");
		}
		if (tildeTokenId == -1) {
			throw new IllegalStateException("Token '~' was not found");
		}
		if (openParenTokenId == -1) {
			throw new IllegalStateException("Token '(' was not found");
		}
	}
}
